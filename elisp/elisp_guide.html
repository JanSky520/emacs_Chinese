<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-09-04 Wed 23:36 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>elisp快速指南</title>
<meta name="author" content="JanSky" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">elisp快速指南</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org88ea1b0">1. 列表处理</a>
<ul>
<li><a href="#org74e9e25">1.1. Lisp 中的列表</a>
<ul>
<li><a href="#orgda15b35">1.1.1. 数字，列表中的列表</a></li>
<li><a href="#org962efe7">1.1.2. Lisp中的原子</a></li>
<li><a href="#org8c08786">1.1.3. 列表中的空白</a></li>
<li><a href="#org97163c4">1.1.4. GNU Emacs 帮助你编写列表</a></li>
</ul>
</li>
<li><a href="#org2286048">1.2. 运行程序</a></li>
<li><a href="#org0a427bf">1.3. 生成错误消息</a></li>
<li><a href="#org8e0da88">1.4. 符号名称与函数定义</a></li>
<li><a href="#org7e3d5ee">1.5. Lisp 解释器</a>
<ul>
<li><a href="#orgec33b40">1.5.1. 复杂情况</a></li>
<li><a href="#org18f23b4">1.5.2. 字节编译</a></li>
</ul>
</li>
<li><a href="#orgb1286e5">1.6. 求值</a>
<ul>
<li><a href="#org4064134">1.6.1. Lisp 解释器的行为</a></li>
<li><a href="#org16a71ec">1.6.2. 求值内部列表</a></li>
</ul>
</li>
<li><a href="#orgd8f366a">1.7. 变量</a>
<ul>
<li><a href="#org065d033">1.7.1. fill-column，一个示例变量</a></li>
<li><a href="#orgfa2bb83">1.7.2. 没有函数的符号的错误信息</a></li>
<li><a href="#org8064cab">1.7.3. 没有值的符号的错误信息</a></li>
</ul>
</li>
<li><a href="#org4f989e4">1.8. 参数</a>
<ul>
<li><a href="#orgb0af22d">1.8.1. 参数的数据类型</a></li>
<li><a href="#org335babe">1.8.2. 作为变量或列表值的参数</a></li>
<li><a href="#org7279a32">1.8.3. 可变数量的参数</a></li>
<li><a href="#org1d912ed">1.8.4. 使用错误类型的对象作为参数</a></li>
<li><a href="#org519f320">1.8.5. message 函数</a></li>
</ul>
</li>
<li><a href="#orgccd76e2">1.9. 设置变量的值</a>
<ul>
<li><a href="#org2ad2dee">1.9.1. 使用 setq</a></li>
<li><a href="#orgdb94826">1.9.2. 计数</a></li>
</ul>
</li>
<li><a href="#org5d021dc">1.10. 总结</a></li>
<li><a href="#org3a0af1e">1.11. 练习</a></li>
</ul>
</li>
<li><a href="#org8f5e0ab">2. 练习计算</a>
<ul>
<li><a href="#org6ac70b4">2.1. 缓冲区名称</a></li>
<li><a href="#org2cb144a">2.2. 获取缓冲区</a></li>
<li><a href="#org82e9612">2.3. 切换缓冲区</a></li>
<li><a href="#org2786da1">2.4. 缓冲区大小和点的位置</a></li>
<li><a href="#org7621ac5">2.5. 练习</a></li>
</ul>
</li>
<li><a href="#org9dc648f">3. 如何编写函数定义</a>
<ul>
<li><a href="#org63b63bf">3.1. defun 宏</a></li>
<li><a href="#orge6bf513">3.2. 安装函数定义</a>
<ul>
<li><a href="#orgbc8d9f4">3.2.1. 安装的效果</a></li>
<li><a href="#org1e13556">3.2.2. 修改函数定义</a></li>
</ul>
</li>
<li><a href="#org13886c2">3.3. 使函数具有交互性</a>
<ul>
<li><a href="#org3133a5b">3.3.1. 交互式的 multiply-by-seven：概述</a></li>
<li><a href="#orgcba5747">3.3.2. 一个交互的乘以七函数</a></li>
</ul>
</li>
<li><a href="#orge53b1d1">3.4. interactive 的不同选项</a></li>
<li><a href="#orgfbd181e">3.5. 永久安装代码</a></li>
<li><a href="#orgd4f7be6">3.6. let</a>
<ul>
<li><a href="#orgaec005a">3.6.1. let 防止混淆</a></li>
<li><a href="#orgd9429f7">3.6.2. let 表达式的部分</a></li>
<li><a href="#orga8e1b1e">3.6.3. 示例 let 表达式</a></li>
<li><a href="#org0b51f5c">3.6.4. 在 let 语句中的未初始化变量</a></li>
<li><a href="#org7c4b0ea">3.6.5. let 如何绑定变量</a></li>
</ul>
</li>
<li><a href="#orgbbabca4">3.7. if 特殊形式</a>
<ul>
<li><a href="#org72bcc79">3.7.1. 更详细地看 if</a></li>
<li><a href="#orgad65aea">3.7.2. type-of-animal 函数的详细解释</a></li>
</ul>
</li>
<li><a href="#orgb256e6e">3.8. If–then–else 表达式</a></li>
<li><a href="#org3f52aa7">3.9. Emacs Lisp 中的真与假</a>
<ul>
<li><a href="#orge8374bd">3.9.1. 对 nil 的解释</a></li>
</ul>
</li>
<li><a href="#orgdb89f44">3.10. save-excursion</a>
<ul>
<li><a href="#orgaf44e41">3.10.1. 光标位置（Point）和标记（Mark）</a></li>
<li><a href="#org8ed3515">3.10.2. save-excursion 表达式的模板</a></li>
</ul>
</li>
<li><a href="#orga5d5672">3.11. 回顾</a></li>
<li><a href="#orgdda7ae7">3.12. 练习</a></li>
</ul>
</li>
<li><a href="#org4a5237e">4. 一些与缓冲区相关的函数</a></li>
</ul>
</div>
</div>


<div id="outline-container-org88ea1b0" class="outline-2">
<h2 id="org88ea1b0"><span class="section-number-2">1.</span> 列表处理</h2>
<div class="outline-text-2" id="text-1">
<p>
对未曾接触过的人来说，Lisp 是一种奇怪的编程语言。在 Lisp 代码中，到处都是括号。
有些人甚至戏称其名称代表“Lots of Isolated Silly Parentheses”（大量孤立的愚蠢括号）。但这种说法是没有依据的。
Lisp 实际上代表的是“LISt Processing”（列表处理），这门编程语言通过将列表（以及列表的列表）置于括号之间来处理它们。
括号标志着列表的边界。有时列表前会有一个单引号‘'’，在 Lisp 中称为单引号。列表是 Lisp 的基础。
</p>
</div>

<div id="outline-container-org74e9e25" class="outline-3">
<h3 id="org74e9e25"><span class="section-number-3">1.1.</span> Lisp 中的列表</h3>
<div class="outline-text-3" id="text-1-1">
<p>
在 Lisp 中，一个列表看起来像这样：'(rose violet daisy buttercup)。这个列表前有一个单引号。
它也可以写成如下形式，看起来更像你可能熟悉的那种列表：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">'(rose
violet
daisy
buttercup)
</pre>
</div>
<p>
这个列表的元素是四种不同的花的名称，彼此之间用空白分隔，并被括号包围，就像田野里用石墙围起来的花朵一样。
</p>
</div>

<div id="outline-container-orgda15b35" class="outline-4">
<h4 id="orgda15b35"><span class="section-number-4">1.1.1.</span> 数字，列表中的列表</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
列表中也可以包含数字，如在这个列表中：(+ 2 2)。这个列表包含一个加号 ‘+’，后面跟着两个数字 ‘2’，它们之间用空格分隔。<br />
</p>

<p>
在 Lisp 中，数据和程序的表示方式是相同的；也就是说，它们都是由单词、数字或其他列表组成的列表，彼此之间用空格分隔，并被括号包围。
（由于程序看起来像数据，一个程序很容易作为另一个程序的数据使用；这是 Lisp 的一个非常强大的功能。）<br />
</p>

<p>
这里是另一个列表，这次其中包含一个列表：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">'(this list has (a list inside of it))
</pre>
</div>
<p>
这个列表的组件是单词 ‘this’、‘list’、‘has’ 和列表 ‘(a list inside of it)’。
内部列表由单词 ‘a’、‘list’、‘inside’、‘of’、‘it’ 组成。
</p>
</div>
</div>

<div id="outline-container-org962efe7" class="outline-4">
<h4 id="org962efe7"><span class="section-number-4">1.1.2.</span> Lisp中的原子</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
在Lisp中，我们所称的“单词”被称为“原子”。这个术语源自“原子”一词的历史含义，意思是“不可分割”。
就Lisp而言，我们在列表中使用的单词不能再分解为更小的部分，否则它们在程序中的意义就不再相同；数字和像‘+’这样的单字符符号也是如此。
另一方面，与古代原子不同，列表可以被分解为多个部分。（参见car、cdr和cons基本函数。）<br />
</p>

<p>
在一个列表中，原子之间用空格分隔。它们可以紧挨着括号。<br />
</p>

<p>
从技术上讲，Lisp中的列表由括号组成，括号内包含由空格分隔的原子、其他列表或同时包含原子和其他列表。
一个列表可以只有一个原子，也可以什么都没有。一个空列表看起来像这样：`()`，被称为“空列表”。
与其他任何东西不同，空列表同时被视为原子和列表。<br />
</p>

<p>
原子和列表的打印表示被称为符号表达式，或更简洁地称为s-表达式。单独的“表达式”一词可以指打印表示，也可以指计算机内部存储的原子或列表。
通常，人们会随意使用“表达式”这一术语。（另外，在许多文本中，“形式”一词也被用作“表达式”的同义词。）<br />
</p>

<p>
顺便提一下，当原子被认为是不可分割时，它们才被命名为“原子”；但后来发现物理原子并非不可分割。
原子的一部分可以分裂出来，或者它可以裂变成两部分，且这两部分大小大致相等。物理原子的命名过于仓促，在其真实本质被发现之前就被命名了。
在Lisp中，某些类型的原子，如数组，可以分为多个部分；但实现这一操作的机制与分裂列表的机制不同。
就列表操作而言，列表中的原子是不可分割的。<br />
</p>

<p>
与英语类似，Lisp 原子的组成字母的含义与这些字母组合成单词后的含义是不同的。
例如，南美洲树懒的名称“ai”与两个单词“a”和“i”的含义完全不同。<br />
</p>

<p>
在自然界中有很多种原子，但在 Lisp 中只有几种：例如，数字，如 37、511 或 1729；以及符号，如‘+’、‘foo’或‘forward-line’。
我们在上面例子中列出的单词都是符号。在日常的 Lisp 对话中，"原子" 这个词不常用，因为程序员通常会更具体地说明他们正在处理的原子类型。
Lisp 编程主要涉及列表中的符号（有时也包括数字）。顺便说一下，前面三个单词构成的括号中的注释是一个符合 Lisp 规范的列表，
因为它由原子（在这种情况下是符号）组成，这些符号用空格分隔并用括号括起来，没有任何非 Lisp 的标点符号。<br />
</p>

<p>
双引号中的文本——即使是句子或段落——也是一个原子。以下是一个例子：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">'(this list includes "text between quotation marks.")
</pre>
</div>
<p>
在 Lisp 中，所有被引号包围的文本，包括标点符号和空格，都被视为一个单一的原子。这种原子称为字符串（"字符串"），
通常用于计算机打印给人类阅读的消息。字符串是一种与数字或符号不同的原子，其使用方式也不同。
</p>
</div>
</div>

<div id="outline-container-org8c08786" class="outline-4">
<h4 id="org8c08786"><span class="section-number-4">1.1.3.</span> 列表中的空白</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
列表中的空白量并不重要。从 Lisp 语言的角度来看：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">'(this list
 looks like this)
</pre>
</div>
<p>
与这个列表是完全相同的：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">'(this list looks like this)
</pre>
</div>
<p>
这两个例子展示的在 Lisp 中是同一个列表，即由符号‘this’、‘list’、‘looks’、‘like’和‘this’按顺序组成的列表。<br />
</p>

<p>
额外的空白和换行是为了让列表更易于人类阅读。当 Lisp 读取表达式时，它会去除所有多余的空白
（但在原子之间至少需要有一个空格，以便区分它们）。<br />
</p>

<p>
虽然看起来有点奇怪，但我们看到的这些例子几乎涵盖了 Lisp 列表的所有形式！
在 Lisp 中的其他列表或多或少都类似于这些例子，只是列表可能会更长、更复杂。
简而言之，一个列表在括号之间，一个字符串在引号之间，一个符号看起来像一个单词，一个数字看起来像一个数字。
（在某些情况下，方括号、点和其他一些特殊字符可能会被使用；然而，我们在大多数情况下都不需要它们。）
</p>
</div>
</div>

<div id="outline-container-org97163c4" class="outline-4">
<h4 id="org97163c4"><span class="section-number-4">1.1.4.</span> GNU Emacs 帮助你编写列表</h4>
<div class="outline-text-4" id="text-1-1-4">
<p>
当你在 GNU Emacs 中使用 Lisp 交互模式或 Emacs Lisp 模式输入 Lisp 表达式时，你可以使用多个命令来格式化 Lisp 表达式，
使其更易于阅读。例如，按下 TAB 键会自动将光标所在的行缩进到正确的位置。
通常，将代码区域正确缩进的命令绑定在 M-C-\ 键上。
缩进的设计使你能够清楚地看到列表的哪些元素属于哪个列表——子列表的元素比外部列表的元素缩进更多。<br />
</p>

<p>
此外，当你输入一个右括号时，Emacs 会短暂地将光标跳回到匹配的左括号处，以便你确认它对应的是哪个左括号。
这非常有用，因为在 Lisp 中你输入的每个列表都必须确保右括号与左括号匹配。
（有关 Emacs 模式的更多信息，请参见《GNU Emacs 手册》中的“主要模式”部分。）
</p>
</div>
</div>
</div>

<div id="outline-container-org2286048" class="outline-3">
<h3 id="org2286048"><span class="section-number-3">1.2.</span> 运行程序</h3>
<div class="outline-text-3" id="text-1-2">
<p>
在 Lisp 中，任何列表都是一个准备运行的程序。如果你运行它（在 Lisp 中的术语是“求值”），
计算机将执行以下三种情况之一：什么都不做，只是返回列表本身；向你发送错误消息；或者，将列表中的第一个符号视为命令并执行某些操作。<br />
</p>

<p>
我在前面部分的一些示例列表前面加的单引号 `’` 被称为“引用”；当它位于列表前时，它告诉 Lisp 对列表不做任何处理，只是按原样接受它
。但是，如果列表前没有引用符号，列表的第一个元素是特殊的：它是计算机必须执行的命令。（在 Lisp 中，这些命令被称为“函数”。）
上面显示的列表 `(+ 2 2)` 前面没有引用符号，因此 Lisp 理解 `+` 是一个指令，要求对列表的其余部分进行处理：将后续的数字相加。<br />
</p>

<p>
如果你在 GNU Emacs 的 Info 中阅读此内容，通过这样对列表进行求值：将光标放在以下列表的右括号之后，然后键入 `C-x C-e`：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(+ 2 2)
</pre>
</div>
<p>
你会看到数字 4 出现在回显区域（你刚刚做的就是对列表求值。回显区域是屏幕底部显示或回显文本的那一行）。
现在，尝试对一个带有引用符号的列表做同样的操作：将光标放在以下列表的右括号之后，然后键入 `C-x C-e`：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">'(this is a quoted list)
</pre>
</div>
<p>
你会看到 `(this is a quoted list)` 出现在回显区域。<br />
</p>

<p>
在这两种情况下，你所做的都是向 GNU Emacs 内的一个名为 Lisp 解释器的程序发出命令，要求解释器对表达式进行求值。
Lisp 解释器的名称源自于一个人为表达式赋予意义并解释它的任务。<br />
</p>

<p>
你也可以对不在列表中的原子进行求值——即那些没有被括号包围的原子；同样，Lisp 解释器会将人类可读的表达式翻译成计算机语言。
但在讨论这个之前（见变量），我们将先讨论当你出错时 Lisp 解释器会做什么。
</p>
</div>
</div>

<div id="outline-container-org0a427bf" class="outline-3">
<h3 id="org0a427bf"><span class="section-number-3">1.3.</span> 生成错误消息</h3>
<div class="outline-text-3" id="text-1-3">
<p>
为了让你在不小心做错时不会过于担心，我们现在将向 Lisp 解释器发出一个命令，以生成错误消息。
这是一个无害的操作；实际上，我们经常会故意生成错误消息。一旦你理解了术语，错误消息实际上是很有帮助的。
与其称它们为“错误”消息，不如称它们为“帮助”消息。它们就像在陌生国度中的路标；虽然解读它们可能很难，但一旦理解了，它们就能指明方向。<br />
</p>

<p>
错误消息由 GNU Emacs 内置的调试器生成。我们将进入调试器。你可以通过输入 `q` 退出调试器。<br />
</p>

<p>
我们要做的是对一个未引用且第一个元素不是有效命令的列表进行求值。
下面是一个几乎与我们刚刚使用的列表完全相同的列表，但没有前面的单引号。将光标放在列表之后，然后输入 `C-x C-e`：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(this is an unquoted list)
</pre>
</div>
<p>
一个 Backtrace 窗口将会打开，你应该在其中看到以下内容：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function this)
  (this is an unquoted list)
  eval((this is an unquoted list) nil)
  elisp--eval-last-sexp(nil)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
</pre>
</div>
<p>
你的光标将位于这个窗口中（你可能需要等待几秒钟才会看到它）。要退出调试器并关闭调试器窗口，输入：q <br />
</p>

<p>
基于我们已经知道的内容，我们几乎可以理解这个错误消息。<br />
</p>

<p>
你应该从下往上读取 Backtrace 缓冲区；它告诉你 Emacs 做了什么。
当你输入 C-x C-e 时，你进行了对命令 eval-last-sexp 的交互调用。
eval 是 "evaluate"（求值）的缩写，而 sexp 是 "symbolic expression"（符号表达式）的缩写。
该命令的意思是 "求值最后一个符号表达式"，也就是光标前面的那个表达式。<br />
</p>

<p>
上面的每一行告诉你 Lisp 解释器接下来求值的内容。最近的操作在最上面。
这个缓冲区被称为 Backtrace 缓冲区，因为它让你能够追踪 Emacs 的操作顺序。<br />
</p>

<p>
在 Backtrace 缓冲区的顶部，你会看到这一行：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">Debugger entered--Lisp error: (void-function this)
</pre>
</div>
<p>
Lisp 解释器试图求值列表的第一个原子，即单词 'this'。正是这个操作产生了错误消息 'void-function this'。<br />
</p>

<p>
消息中包含了 'void-function' 和 'this' 这两个词。<br />
</p>

<p>
‘function’ 这个词之前提到过一次。它是一个非常重要的词。对于我们的目的，
我们可以这样定义它：函数是一组给计算机的指令，告诉计算机执行某些操作。<br />
</p>

<p>
现在我们可以开始理解这个错误消息：'void-function this'。函数（即单词 'this'）没有定义任何一组指令让计算机执行。<br />
</p>

<p>
这个略显奇怪的词语 'void-function' 是为了说明 Emacs Lisp 的实现方式，即当一个符号没有附加函数定义时，应该包含指令的位置是空的。<br />
</p>

<p>
另一方面，由于我们能够通过求值 (+ 2 2) 成功地得到 2 加 2 的结果，
我们可以推断出符号 + 必定有一组指令让计算机遵循，而这些指令必须是将 `+` 后面的数字相加。<br />
</p>

<p>
可以避免在这种情况下 Emacs 进入调试器。我们在这里不解释如何做到这一点，但我们会提到结果是什么样的，
因为如果你在使用的某些 Emacs 代码中遇到错误，你可能会遇到类似的情况。
在这种情况下，你只会看到一行错误消息；它会出现在回显区域，看起来像这样：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">Symbol's function definition is void: this
</pre>
</div>
<p>
当你输入一个按键时，哪怕只是移动光标，消息就会消失。<br />
</p>

<p>
我们已经知道 “Symbol” 这个词的含义。它指的是列表的第一个原子，即单词 “this”。“function” 这个词指的是告诉计算机该做什么的指令。
（从技术上讲，符号告诉计算机在哪里找到指令，但这是一个我们目前可以忽略的复杂问题。）<br />
</p>

<p>
这个错误消息可以理解为：‘Symbol's function definition is void: this’。符号（即单词 “this”）缺少让计算机执行的指令。
</p>
</div>
</div>

<div id="outline-container-org8e0da88" class="outline-3">
<h3 id="org8e0da88"><span class="section-number-3">1.4.</span> 符号名称与函数定义</h3>
<div class="outline-text-3" id="text-1-4">
<p>
基于我们迄今为止讨论的内容，我们可以明确 Lisp 的另一个特征——一个重要的特征：像 + 这样的符号本身并不是计算机要执行的那组指令。
相反，符号可能只是暂时用来定位定义或指令集的一种方式。我们所看到的是用来找到这些指令的名称。
人的名字也是同样的道理。我可以被称为 "Bob"；然而，我并不是字母 "B"、"o"、"b"，而是（或曾经是）与某个特定生命形式一致关联的意识。
名字并不是我本身，但它可以用来指代我。<br />
</p>

<p>
在 Lisp 中，一组指令可以附加到多个名称上。例如，用于加法运算的计算机指令可以同时链接到符号 plus 和符号 +
（在某些 Lisp 方言中就是如此）。在人类社会中，我可以被称为 "Robert" 或 "Bob" 以及其他名字。<br />
</p>

<p>
另一方面，一个符号在同一时间只能有一个函数定义与之关联。否则，计算机会因为不知道使用哪个定义而感到困惑。
如果在人类社会中也存在这种情况，那么世界上只有一个人可以叫 "Bob"。
不过，符号名称所指向的函数定义可以轻松更改。（参见《设置函数定义》）。<br />
</p>

<p>
由于 Emacs Lisp 规模庞大，通常习惯于为符号命名，以便识别该函数所属的 Emacs 部分。
因此，处理 Texinfo 的所有函数名称都以 "texinfo-" 开头，而处理邮件读取的函数名称则以 "rmail-" 开头。
</p>
</div>
</div>

<div id="outline-container-org7e3d5ee" class="outline-3">
<h3 id="org7e3d5ee"><span class="section-number-3">1.5.</span> Lisp 解释器</h3>
<div class="outline-text-3" id="text-1-5">
<p>
基于我们所见的内容，我们现在可以开始理解 Lisp 解释器在我们命令它求值一个列表时的工作原理。
首先，它查看列表前是否有引号；如果有，引擎解释器就直接返回列表。
另一方面，如果没有引号，解释器会查看列表中的第一个元素，并检查它是否有函数定义。
如果有，解释器就执行函数定义中的指令。否则，解释器会打印一条错误消息。<br />
</p>

<p>
这就是 Lisp 的工作原理，很简单。接下来我们还会探讨一些额外的复杂情况，但这些是基本原理。
当然，要编写 Lisp 程序，你需要知道如何编写函数定义并将其附加到名称上，以及如何在不让自己或计算机混淆的情况下做到这一点。<br />
</p>
</div>

<div id="outline-container-orgec33b40" class="outline-4">
<h4 id="orgec33b40"><span class="section-number-4">1.5.1.</span> 复杂情况</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
现在，我们来探讨第一个复杂情况。除了列表外，Lisp 解释器还可以求值一个未加引号且没有括号的符号。
Lisp 解释器会尝试将该符号的值作为变量来确定。这种情况在变量部分有描述。（参见《变量》）。<br />
</p>

<p>
第二个复杂情况出现是因为有些函数不常见，它们的工作方式与常规方法不同。这些不常规的函数被称为特殊形式（special forms）。
它们用于一些特殊的任务，比如定义函数，而且数量不多。在接下来的几章中，你将会接触到一些较为重要的特殊形式。<br />
</p>

<p>
除了特殊形式，还有宏。宏是 Lisp 中定义的一种结构，它与函数的不同之处在于，宏将一个 Lisp 表达式翻译为另一个表达式，
以替代原始表达式进行求值。（参见《Lisp 宏》）。<br />
</p>

<p>
对于本介绍的目的，你不需要过于担心某个东西是特殊形式、宏，还是普通函数。
例如，if 是一种特殊形式（参见《if 特殊形式》），但 when 是一种宏（参见《Lisp 宏》）。
在早期版本的 Emacs 中，defun 是一种特殊形式，但现在它是一种宏（参见《defun 宏》）。不过，它的行为仍然相同。<br />
</p>

<p>
最后一个复杂情况是：如果 Lisp 解释器所查看的函数不是特殊形式，并且它是列表的一部分，解释器会查看该列表中是否包含另一个列表。
如果存在内部列表，Lisp 解释器首先会确定如何处理该内部列表，然后再处理外部列表。
如果内部列表中还有嵌套的列表，解释器会先处理那个嵌套的列表，以此类推。它总是首先处理最内层的列表。
解释器首先处理最内层的列表，以求值该列表的结果。该结果可能会被外层表达式使用。<br />
</p>

<p>
否则，解释器会从左到右依次处理每个表达式。
</p>
</div>
</div>

<div id="outline-container-org18f23b4" class="outline-4">
<h4 id="org18f23b4"><span class="section-number-4">1.5.2.</span> 字节编译</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
关于解释的另一个方面：Lisp 解释器能够解释两种实体：人类可读的代码（我们将专注于此），
以及经过特殊处理的代码，称为字节编译代码，这种代码不可供人类阅读。字节编译代码的运行速度比人类可读代码更快。<br />
</p>

<p>
你可以通过运行 byte-compile-file 等编译命令之一，将人类可读代码转换为字节编译代码。
字节编译代码通常存储在以 .elc 为扩展名的文件中，而不是 .el 扩展名的文件中。
在 emacs/lisp 目录中你会看到这两种类型的文件；需要阅读的是扩展名为 .el 的文件。<br />
</p>

<p>
实际上，对于大多数自定义或扩展 Emacs 的操作，你不需要进行字节编译，因此我在此不会讨论这一话题。
有关字节编译的完整描述，请参见《GNU Emacs Lisp 参考手册》中的字节编译部分。
</p>
</div>
</div>
</div>

<div id="outline-container-orgb1286e5" class="outline-3">
<h3 id="orgb1286e5"><span class="section-number-3">1.6.</span> 求值</h3>
<div class="outline-text-3" id="text-1-6">
<p>
当 Lisp 解释器处理一个表达式时，这一活动被称为求值。我们说解释器“对表达式进行求值”。
我之前已经多次使用过这个术语。根据《韦氏新大学词典》，这个词源自日常语言的用法，意为“确定价值或数量；评估”。
</p>
</div>

<div id="outline-container-org4064134" class="outline-4">
<h4 id="org4064134"><span class="section-number-4">1.6.1.</span> Lisp 解释器的行为</h4>
<div class="outline-text-4" id="text-1-6-1">
<p>
在对一个表达式求值之后，Lisp 解释器很可能会返回计算机通过执行函数定义中的指令所产生的值，或者可能会放弃该函数并产生一条错误消息。
（解释器也可能被“抛到”另一个函数中，或者可能会试图在无限循环中不断重复它正在做的事情。这些行为较为少见，我们可以忽略它们。）
最常见的是，解释器会返回一个值。<br />
</p>

<p>
在解释器返回一个值的同时，它也可能会执行其他操作，例如移动光标或复制文件；这种类型的操作被称为副作用。
对我们人类来说很重要的操作，比如打印结果，对于 Lisp 解释器来说通常是副作用。学习如何使用副作用相对容易。<br />
</p>

<p>
总而言之，对符号表达式进行求值通常会导致 Lisp 解释器返回一个值，并可能执行一个副作用；否则会产生一个错误。<br />
</p>
</div>
</div>

<div id="outline-container-org16a71ec" class="outline-4">
<h4 id="org16a71ec"><span class="section-number-4">1.6.2.</span> 求值内部列表</h4>
<div class="outline-text-4" id="text-1-6-2">
<p>
如果求值作用于嵌套在另一个列表中的列表，则外部列表在求值时可能会使用第一次求值返回的值作为信息。
这就解释了为什么先对内部表达式进行求值：它们返回的值会被外部表达式使用。<br />
</p>

<p>
我们可以通过求值另一个加法示例来探究这一过程。将光标放在以下表达式之后，然后输入 C-x C-e：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(+ 2 (+ 3 3))  
</pre>
</div>
<p>
数字 8 会出现在回显区域。<br />
</p>

<p>
发生的情况是，Lisp 解释器首先对内部表达式 (+ 3 3) 进行求值，返回的值是 6；然后，它对外部表达式求值，
仿佛它是 (+ 2 6)，结果返回值是 8。由于没有更多的外部表达式需要求值，解释器将该值打印在回显区域。<br />
</p>

<p>
现在，C-x C-e 这一组合键调用的命令名称变得容易理解了：这个命令的名称是 eval-last-sexp。
sexp 是 “symbolic expression”（符号表达式）的缩写，而 eval 是 “evaluate”（求值）的缩写。该命令对最后一个符号表达式进行求值。<br />
</p>

<p>
作为实验，你可以尝试将光标放在表达式后面的下一行的开头，或者放在表达式内部，然后对该表达式进行求值。<br />
</p>

<p>
以下是该表达式的另一个副本：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(+ 2 (+ 3 3))  
</pre>
</div>
<p>
如果你将光标放在紧跟表达式之后的空白行的开头，并输入 C-x C-e，你仍然会在回显区域看到数字 8。
现在尝试将光标放在表达式内部。如果你将光标放在倒数第二个括号之后（所以看起来它位于最后一个括号上方），你会在回显区域看到数字 6！
这是因为该命令对表达式 (+ 3 3) 进行了求值。<br />
</p>

<p>
现在将光标放在数字之后。输入 C-x C-e，你将得到这个数字本身。
在 Lisp 中，如果你对一个数字进行求值，你会得到这个数字本身——这就是数字与符号的区别。
如果你对以 + 等符号开头的列表进行求值，你会得到计算机执行与该名称关联的函数定义中的指令后的结果。
如果对符号本身进行求值，则会发生不同的情况，我们将在下一节中看到。<br />
</p>
</div>
</div>
</div>

<div id="outline-container-orgd8f366a" class="outline-3">
<h3 id="orgd8f366a"><span class="section-number-3">1.7.</span> 变量</h3>
<div class="outline-text-3" id="text-1-7">
<p>
在 Emacs Lisp 中，一个符号可以附加一个值，就像它可以附加一个函数定义一样。两者是不同的。
函数定义是一组计算机将执行的指令。而一个值则是某种可以变化的东西，比如数字或名字（这也是为什么这样的符号被称为变量）。
符号的值可以是 Lisp 中的任何表达式，例如符号、数字、列表或字符串。一个有值的符号通常被称为变量。<br />
</p>

<p>
一个符号可以同时附加函数定义和值，也可以只附加其中一个。这两者是独立的。
这有点类似于“剑桥”这个名字既可以指代马萨诸塞州的城市，也可以附加一些信息，比如“著名的编程中心”。<br />
</p>

<p>
另一种理解方式是将符号想象成一个有抽屉的柜子。函数定义放在一个抽屉里，值放在另一个抽屉里，等等。
存放值的抽屉中的内容可以更改，而不会影响存放函数定义的抽屉中的内容，反之亦然。
</p>
</div>

<div id="outline-container-org065d033" class="outline-4">
<h4 id="org065d033"><span class="section-number-4">1.7.1.</span> fill-column，一个示例变量</h4>
<div class="outline-text-4" id="text-1-7-1">
<p>
变量 fill-column 说明了一个附加了值的符号：在每个 GNU Emacs 缓冲区中，这个符号都被设置为某个值，通常是 72 或 70，
但有时也会设置为其他值。要查看这个符号的值，可以直接对其进行求值。
如果你正在 GNU Emacs 中的 Info 阅读此内容，你可以将光标放在符号后面，然后按 C-x C-e：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">fill-column
</pre>
</div>
<p>
当我输入 `C-x C-e` 后，Emacs 在回显区域显示了数字 72。这是我在编写这段文字时 fill-column 被设置的值。
在你的 Info 缓冲区中，这个值可能不同。请注意，作为变量返回的值和函数执行其指令后返回的值，其显示方式完全相同。
从 Lisp 解释器的角度来看，返回的值就是返回的值。一旦知道了这个值，它来自什么表达式就不再重要了。<br />
</p>

<p>
一个符号可以附加任何值，或者用行话来说，我们可以将变量绑定到一个值：可以是一个数字，比如 72；
可以是一个字符串，比如 "such as this"；可以是一个列表，比如 (spruce pine oak)；我们甚至可以将一个变量绑定到一个函数定义。<br />
</p>

<p>
符号可以通过几种方式绑定到一个值。有关其中一种方式的信息，请参阅“设置变量的值”。
</p>
</div>
</div>

<div id="outline-container-orgfa2bb83" class="outline-4">
<h4 id="orgfa2bb83"><span class="section-number-4">1.7.2.</span> 没有函数的符号的错误信息</h4>
<div class="outline-text-4" id="text-1-7-2">
<p>
当我们对 fill-column 求值以查看其作为变量的值时，没有在这个词周围加上括号。这是因为我们并不打算将其用作函数名。<br />
</p>

<p>
如果 fill-column 是列表中的第一个或唯一元素，Lisp 解释器将尝试查找附加给它的函数定义。
但 fill-column 并没有函数定义。试着对以下内容求值：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(fill-column)
</pre>
</div>
<p>
你会创建一个名为 <b>Backtrace</b> 的缓冲区，其中显示：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function fill-column)
  (fill-column)
  eval((fill-column) nil)
  elisp--eval-last-sexp(nil)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
</pre>
</div>
<p>
（记住，要退出调试器并关闭调试器窗口，在 <b>Backtrace</b> 缓冲区中输入 q。）
</p>
</div>
</div>

<div id="outline-container-org8064cab" class="outline-4">
<h4 id="org8064cab"><span class="section-number-4">1.7.3.</span> 没有值的符号的错误信息</h4>
<div class="outline-text-4" id="text-1-7-3">
<p>
如果你尝试对一个没有绑定值的符号进行求值，你将收到一条错误信息。你可以通过尝试我们的 2 加 2 来看到这一点。
在以下表达式中，将光标放在 + 后面、第一个数字 2 之前，然后输入 C-x C-e：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(+ 2 2)
</pre>
</div>
<p>
在 GNU Emacs 22 中，你会创建一个名为 <b>Backtrace</b> 的缓冲区，其中显示：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-variable +)
  eval(+)
  elisp--eval-last-sexp(nil)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
</pre>
</div>
<p>
（同样，你可以通过在 <b>Backtrace</b> 缓冲区中输入 q 来退出调试器。）<br />
</p>

<p>
这个回溯与我们看到的第一个错误信息不同，第一个错误信息显示为“Debugger entered&#x2013;Lisp error: (void-function this)”。
在这个案例中，函数没有作为变量的值；而在另一个错误信息中，函数（“this”这个词）没有定义。<br />
</p>

<p>
在我们对 + 进行的实验中，我们让 Lisp 解释器对 + 进行求值，并查找变量的值，而不是函数定义。
我们通过将光标放在符号后面，而不是像之前那样放在封闭列表的括号后面来实现这一点。
结果，Lisp 解释器求值了前面的 s-表达式，在这种情况下就是 + 本身。<br />
</p>

<p>
由于 + 没有绑定任何值，只有函数定义，因此错误信息报告该符号作为变量的值为空。
</p>
</div>
</div>
</div>

<div id="outline-container-org4f989e4" class="outline-3">
<h3 id="org4f989e4"><span class="section-number-3">1.8.</span> 参数</h3>
<div class="outline-text-3" id="text-1-8">
<p>
为了了解信息如何传递给函数，我们再次来看一下我们熟悉的例子，即两个数相加。在 Lisp 中，这样写：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(+ 2 2)
</pre>
</div>
<p>
如果你对这个表达式求值，数字 4 会出现在你的回显区域。Lisp 解释器的作用是将 + 后面的数字相加。<br />
</p>

<p>
这些被 + 加起来的数字被称为函数 + 的参数。这些数字是传递给函数的信息。<br />
</p>

<p>
“参数”一词来源于数学中的用法，并不指两个人之间的争论；相反，它指的是传递给函数的信息，在这个例子中就是传递给 + 的信息。
在 Lisp 中，函数的参数是跟在函数后面的原子或列表。通过对这些原子或列表求值获得的值会传递给函数。
不同的函数需要不同数量的参数，有些函数甚至不需要参数。
</p>
</div>

<div id="outline-container-orgb0af22d" class="outline-4">
<h4 id="orgb0af22d"><span class="section-number-4">1.8.1.</span> 参数的数据类型</h4>
<div class="outline-text-4" id="text-1-8-1">
<p>
传递给函数的数据类型取决于函数使用的信息类型。像 + 这样的函数，其参数必须是数值，因为 + 是用来进行数值相加的。
而其他函数则会使用不同类型的数据作为参数。<br />
</p>

<p>
例如，concat 函数将两个或多个文本字符串连接在一起，生成一个新的字符串。它的参数是字符串。
将两个字符串 "abc" 和 "def" 连接起来会生成单一字符串 "abcdef"。你可以通过对以下表达式求值来验证这一点：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(concat "abc" "def")
</pre>
</div>
<p>
对这个表达式求值的结果是 "abcdef"。
</p>

<p>
像 substring 这样的函数则会同时使用字符串和数字作为参数。这个函数返回字符串的一部分，即第一个参数的子字符串。
substring 函数接受三个参数。第一个参数是字符字符串，第二个和第三个参数是数字，
用于指示子字符串的起始位置（包含）和结束位置（不包含）。这些数字表示从字符串开头起字符（包括空格和标点符号）的计数。
请注意，字符串中的字符编号从零开始，而不是从一开始。<br />
</p>

<p>
例如，如果你对以下表达式求值：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(substring "The quick brown fox jumped." 16 19)
</pre>
</div>
<p>
你会在回显区域看到 "fox"。这些参数包括字符串和两个数字。<br />
</p>

<p>
请注意，传递给 substring 的字符串虽然由几个用空格分隔的单词组成，但它仍然是一个单一的原子。
Lisp 将两个引号之间的所有内容都视为字符串的一部分，包括空格。
你可以将 substring 函数视为一种“原子粉碎机”，因为它能够从一个不可分割的原子中提取出一部分。
不过，substring 只能从字符串类型的参数中提取子字符串，不能从其他类型的原子（如数字或符号）中提取。
</p>
</div>
</div>

<div id="outline-container-org335babe" class="outline-4">
<h4 id="org335babe"><span class="section-number-4">1.8.2.</span> 作为变量或列表值的参数</h4>
<div class="outline-text-4" id="text-1-8-2">
<p>
参数可以是一个符号，当对其求值时会返回一个值。
例如，当单独对符号 fill-column 求值时，它会返回一个数字。这个数字可以用于加法运算中。<br />
</p>

<p>
将光标放在以下表达式后面，然后输入 C-x C-e：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(+ 2 fill-column)
</pre>
</div>
<p>
结果将是一个比单独求值 fill-column 时多出 2 的数字。对我来说，这是 74，因为我的 fill-column 值是 72。<br />
</p>

<p>
正如我们刚刚看到的，参数可以是一个符号，在求值时返回一个值。此外，参数还可以是一个列表，在求值时返回一个值。
例如，在以下表达式中，函数 concat 的参数是字符串 "The " 和 " red foxes." 以及列表 (number-to-string (+ 2 fill-column))。
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(concat "The " (number-to-string (+ 2 fill-column)) " red foxes.")
</pre>
</div>
<p>
如果你对这个表达式求值——并且如果你的 Emacs 中 fill-column 的值为 72——那么回显区域中将显示 "The 74 red foxes."。
（注意，你必须在单词 "The" 后和单词 "red" 前加上空格，这样它们才会出现在最终的字符串中。
number-to-string 函数将加法函数返回的整数转换为字符串。number-to-string 也被称为 int-to-string。）
</p>
</div>
</div>

<div id="outline-container-org7279a32" class="outline-4">
<h4 id="org7279a32"><span class="section-number-4">1.8.3.</span> 可变数量的参数</h4>
<div class="outline-text-4" id="text-1-8-3">
<p>
一些函数，例如 concat、+ 或 <b>，可以接受任意数量的参数。（</b> 是乘法的符号。）
你可以通过对以下每个表达式按常规方式求值来验证这一点。回显区域中显示的结果在文本中用 ⇒ 表示，你可以将其理解为“求值结果为”。<br />
</p>

<p>
在第一组中，这些函数没有参数：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(+)       ⇒ 0

(*)       ⇒ 1
</pre>
</div>
<p>
在这一组中，每个函数有一个参数：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(+ 3)     ⇒ 3

(* 3)     ⇒ 3
</pre>
</div>
<p>
在这一组中，每个函数有三个参数：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(+ 3 4 5) ⇒ 12

(* 3 4 5) ⇒ 60
</pre>
</div>
</div>
</div>

<div id="outline-container-org1d912ed" class="outline-4">
<h4 id="org1d912ed"><span class="section-number-4">1.8.4.</span> 使用错误类型的对象作为参数</h4>
<div class="outline-text-4" id="text-1-8-4">
<p>
当一个函数被传递了错误类型的参数时，Lisp 解释器会生成一条错误消息。例如，+ 函数期望其参数的值是数字。
作为实验，我们可以传递一个引用的符号 hello 而不是数字。将光标放在以下表达式后面，然后输入 C-x C-e：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(+ 2 'hello)
</pre>
</div>
<p>
当你这样做时，会生成一条错误消息。发生的情况是，+ 试图将 2 与 hello 返回的值相加，
但 hello 返回的值是符号 hello，而不是一个数字。只有数字才能相加，所以 + 无法执行加法操作。<br />
</p>

<p>
你将创建并进入一个名为 <b>Backtrace</b> 的缓冲区，其中显示：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error:
         (wrong-type-argument number-or-marker-p hello)
  +(2 hello)
  eval((+ 2 'hello) nil)
  elisp--eval-last-sexp(t)
  eval-last-sexp(nil)
  funcall-interactively(eval-print-last-sexp nil)
  call-interactively(eval-print-last-sexp nil nil)
  command-execute(eval-print-last-sexp)
---------- Buffer: *Backtrace* ----------
</pre>
</div>
<p>
像往常一样，错误信息试图提供帮助，并在你学会如何解读它之后变得容易理解。<br />
</p>

<p>
错误消息的第一部分很直接，提示“错误的类型参数”（wrong type argument）。
接下来是一个看起来神秘的术语“number-or-marker-p”。这个术语试图告诉你 + 函数期望接收到哪种类型的参数。<br />
</p>

<p>
符号 number-or-marker-p 表示 Lisp 解释器正在尝试确定提供给它的信息（参数的值）是否为数字或标记（代表缓冲区位置的特殊对象）。
它的作用是测试 + 函数是否接收到可以相加的数字。它还测试参数是否是被称为标记的东西，这是一种 Emacs Lisp 的特定功能。
（在 Emacs 中，缓冲区中的位置记录为标记。当使用 C-@ 或 C-SPC 命令设置标记时，其位置作为标记保存。
标记可以被视为一个数字——该位置距缓冲区起始位置的字符数。）在 Emacs Lisp 中，`+` 可以用于将标记位置的数值相加。<br />
</p>

<p>
number-or-marker-p 中的 p 是早期 Lisp 编程实践的体现。p 代表谓词（predicate）。
在早期 Lisp 研究者使用的术语中，谓词指的是一个判断某个属性是“真”还是“假”的函数。
因此，p 告诉我们 number-or-marker-p 是一个函数的名称，该函数用于判断提供的参数是否为数字或标记。
其他以 p 结尾的 Lisp 符号包括 zerop（一个测试其参数是否为零的函数）和 listp（一个测试其参数是否为列表的函数）。<br />
</p>

<p>
最后，错误消息的最后一部分是符号 hello。这是传递给 + 的参数的值。
如果传递给 + 的参数是正确类型的对象，这个值会是一个数字，例如 37，而不是像 hello 这样的符号。
但在那种情况下，你就不会收到错误信息了。
</p>
</div>
</div>

<div id="outline-container-org519f320" class="outline-4">
<h4 id="org519f320"><span class="section-number-4">1.8.5.</span> message 函数</h4>
<div class="outline-text-4" id="text-1-8-5">
<p>
和 + 函数一样，message 函数也可以接受可变数量的参数。它用于向用户发送消息，非常有用，因此我们将在这里介绍它。<br />
</p>

<p>
消息会显示在回显区域。例如，你可以通过对以下列表求值，将一条消息打印在你的回显区域中：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(message "This message appears in the echo area!")
</pre>
</div>
<p>
双引号之间的整个字符串是一个单一的参数，并将被完整打印。
（注意，在这个例子中，消息本身会在回显区域中显示在双引号内；这是因为你看到了 message 函数返回的值。
在你编写的程序中，大多数使用 message 的情况下，文本会作为副作用打印在回显区域，而不会带有引号。
有关此类示例，请参阅 multiply-by-seven 的详细介绍。）<br />
</p>

<p>
然而，如果在引用的字符串中有一个 '%s'，message 函数不会按原样打印 '%s'，而是会查找字符串之后的参数。
它会对第二个参数求值，并在字符串中 `'%s'` 所在的位置打印该值。<br />
</p>

<p>
你可以通过将光标放在以下表达式后并输入 C-x C-e 来验证这一点：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(message "The name of this buffer is: %s." (buffer-name))
</pre>
</div>
<p>
在 Info 中，回显区域会显示 "The name of this buffer is: <b>info</b>."。
buffer-name 函数返回缓冲区的名称作为字符串，message 函数将其插入 %s 的位置。<br />
</p>

<p>
要将一个值以整数形式打印，可以像使用 %s 一样使用 %d。例如，要在回显区域中打印 `fill-column` 的值，可以对以下表达式求值：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(message "The value of fill-column is %d." fill-column)
</pre>
</div>
<p>
在我的系统上，当我对这个列表求值时，回显区域会显示 "The value of fill-column is 72."。<br />
</p>

<p>
如果引用的字符串中有多个 %s，第一个 %s 位置会打印引用字符串后第一个参数的值，第二个 %s 位置会打印第二个参数的值，依此类推。<br />
</p>

<p>
例如，如果你对以下表达式求值：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(message "There are %d %s in the office!"
       (- fill-column 14) "pink elephants")
</pre>
</div>
<p>
在你的回显区域中会出现一条相当异想天开的消息。在我的系统上，它显示为 "There are 58 pink elephants in the office!"。<br />
</p>

<p>
表达式 (- fill-column 14) 会被求值，得到的数字将被插入到 %d 的位置；
而双引号中的字符串 "pink elephants" 被视为一个单独的参数，并被插入到 %s 的位置。
（也就是说，双引号之间的字符串求值为其自身，就像数字一样。）<br />
</p>

<p>
最后，这是一个稍微复杂的例子，不仅说明了如何计算一个数字，还展示了如何在表达式中使用另一个表达式来生成替换 %s 的文本：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(message "He saw %d %s"
         (- fill-column 32)
         (concat "red "
                 (substring
                  "The quick brown foxes jumped." 16 21)
                 " leaping."))
</pre>
</div>
<p>
在这个例子中，message 有三个参数：字符串 "He saw %d %s"，表达式 (- fill-column 32)，以及以 concat 函数开头的表达式。
(- fill-column 32) 的求值结果被插入到 %d 的位置，而 concat 表达式的返回值则被插入到 %s 的位置。<br />
</p>

<p>
当你的 fill-column 值为 70 并且你对这个表达式求值时，回显区域会显示消息 "He saw 38 red foxes leaping."。
</p>
</div>
</div>
</div>

<div id="outline-container-orgccd76e2" class="outline-3">
<h3 id="orgccd76e2"><span class="section-number-3">1.9.</span> 设置变量的值</h3>
<div class="outline-text-3" id="text-1-9">
<p>
有几种方法可以为变量赋值。其中一种方法是使用特殊形式 setq。另一种方法是使用 let（参见 let）。
在专业术语中，这个过程称为将变量绑定到一个值。<br />
</p>

<p>
以下部分不仅描述了 setq 的工作原理，还说明了参数是如何传递的。
</p>
</div>

<div id="outline-container-org2ad2dee" class="outline-4">
<h4 id="org2ad2dee"><span class="section-number-4">1.9.1.</span> 使用 setq</h4>
<div class="outline-text-4" id="text-1-9-1">
<p>
要将符号 flowers 的值设置为列表 (rose violet daisy buttercup)，请通过将光标放在表达式后面并按下 C-x C-e 来对以下表达式求值：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(setq flowers '(rose violet daisy buttercup))
</pre>
</div>
<p>
回显区域会显示列表 (rose violet daisy buttercup)，这是 setq 特殊形式返回的内容。
作为副作用，符号 flowers 被绑定到该列表；也就是说，符号 flowers，可以视为一个变量，被赋予了这个列表作为其值。
（顺便说一下，这个过程说明了对 Lisp 解释器设置值的副作用可以是我们人类感兴趣的主要效果。
这是因为每个 Lisp 函数必须返回一个值，除非它遇到错误，但它只有在被设计为具有副作用时才会有副作用。）<br />
</p>

<p>
在对 setq 表达式求值后，你可以对符号 flowers 求值，它将返回你刚刚设置的值。以下是这个符号。将光标放在它后面并输入 C-x C-e。
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">flowers
</pre>
</div>
<p>
当你对 flowers 求值时，回显区域会显示列表 (rose violet daisy buttercup)。<br />
</p>

<p>
顺便提一下，如果你对带有前置单引号的变量 'flowers 求值，你将在回显区域看到的是符号本身，即 flowers。
以下是带有引号的符号，你可以试试这个：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">'flowers
</pre>
</div>
<p>
另外，作为一种额外的方便，setq 允许你在一个表达式中为多个不同的变量设置不同的值。<br />
</p>

<p>
要使用 setq 将变量 carnivores 的值设置为列表 '(lion tiger leopard)，可以使用以下表达式：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(setq carnivores '(lion tiger leopard))
</pre>
</div>
<p>
此外，setq 可以用来为不同的变量分配不同的值。第一个参数被绑定到第二个参数的值，第三个参数被绑定到第四个参数的值，依此类推。
例如，你可以使用以下表达式将一组树的列表分配给符号 trees，并将一组食草动物的列表分配给符号 herbivores：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(setq trees '(pine fir oak maple)
      herbivores '(gazelle antelope zebra))
</pre>
</div>
<p>
（这个表达式同样可以放在一行上，但可能不适合在一页上显示；而且人类更容易阅读格式整齐的列表。）<br />
</p>

<p>
虽然我一直在使用“赋值”这个术语，但还有另一种理解 setq 工作方式的方式，那就是 setq 使符号指向列表。
这种思维方式非常普遍，在后续章节中，我们将遇到至少一个名称中包含“指针”的符号。
这个名称的选择是因为该符号有一个值，特别是一个列表，附加在它上面；或者换句话说，符号被设置为指向列表。
</p>
</div>
</div>

<div id="outline-container-orgdb94826" class="outline-4">
<h4 id="orgdb94826"><span class="section-number-4">1.9.2.</span> 计数</h4>
<div class="outline-text-4" id="text-1-9-2">
<p>
下面是一个使用 setq 进行计数的示例。这可以用于计算你的程序某部分重复执行的次数。
首先，将一个变量设置为零；然后每次程序重复执行时，将这个数字加一。
要做到这一点，你需要一个变量作为计数器，以及两个表达式：一个初始的 setq 表达式将计数器变量设置为零；
第二个 setq 表达式在每次被计算时增加计数器的值。
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(setq counter 0)                ; 这是初始化器。

(setq counter (+ counter 1))    ; 这是增量器。

counter                         ; 这是计数器。
</pre>
</div>
<p>
（‘;’ 后的文字是注释。详见“更改函数定义”部分。）<br />
</p>

<p>
如果你计算第一个表达式，即初始化器 (setq counter 0)，然后计算第三个表达式 counter，回显区域将显示数字 0。
如果你接着计算第二个表达式，即增量器 (setq counter (+ counter 1))，计数器将获得值 1。
因此，如果你再次计算 counter，回显区域将显示数字 1。每次你计算第二个表达式，计数器的值都会增加。<br />
</p>

<p>
当你计算增量器 (setq counter (+ counter 1)) 时，Lisp 解释器首先计算最里面的列表，即加法。
为了计算这个列表，它必须计算变量 counter 和数字 1。当它计算变量 counter 时，会获取其当前值。
然后将这个值和数字 1 传递给 +，后者将它们相加。这个和作为内部列表的值返回，并传递给 setq，
后者将变量 counter 设置为这个新值。因此，变量 counter 的值发生了变化。
</p>
</div>
</div>
</div>

<div id="outline-container-org5d021dc" class="outline-3">
<h3 id="org5d021dc"><span class="section-number-3">1.10.</span> 总结</h3>
<div class="outline-text-3" id="text-1-10">
<p>
学习 Lisp 就像爬山，最开始的部分是最陡峭的。你现在已经攀登了最困难的部分，接下来随着你的进步会变得越来越容易。<br />
</p>

<p>
总结如下：
</p>
<ul class="org-ul">
<li>Lisp 程序由表达式组成，表达式可以是列表或单个原子。</li>
<li>列表由零个或多个原子或内嵌列表组成，这些元素之间用空格分隔，并由括号包围。列表可以为空。</li>
<li>原子可以是多个字符组成的符号，如 forward-paragraph，也可以是单个字符的符号，如 +，或者是双引号括起来的字符串，或数字。</li>
<li>数字的值就是它本身。</li>
<li>双引号括起来的字符串的值也是它本身。</li>
<li>当你单独计算一个符号时，会返回它的值。</li>
<li>当你计算一个列表时，Lisp 解释器会查看列表中的第一个符号，然后查看绑定到该符号的函数定义。接着会执行函数定义中的指令。</li>
<li>单引号 ' 告诉 Lisp 解释器返回紧随其后的表达式本身，而不是像没有引号时那样进行计算。</li>
<li>参数是传递给函数的信息。函数的参数是通过计算列表中除了第一个元素以外的其他元素得到的。</li>
<li>函数在被计算时总是返回一个值（除非出现错误）；此外，它还可能执行一些作为副作用的操作。在许多情况下，函数的主要目的是产生副作用。</li>
</ul>
</div>
</div>

<div id="outline-container-org3a0af1e" class="outline-3">
<h3 id="org3a0af1e"><span class="section-number-3">1.11.</span> 练习</h3>
<div class="outline-text-3" id="text-1-11">
<p>
几个简单的练习：
</p>
<ol class="org-ol">
<li>通过计算一个不在括号内的适当符号生成一条错误信息。</li>
<li>通过计算一个在括号内的适当符号生成一条错误信息。</li>
<li>创建一个每次递增2而不是1的计数器。</li>
<li>编写一个在计算时在回显区域打印信息的表达式。</li>
</ol>
</div>
</div>
</div>


<div id="outline-container-org8f5e0ab" class="outline-2">
<h2 id="org8f5e0ab"><span class="section-number-2">2.</span> 练习计算</h2>
<div class="outline-text-2" id="text-2">
<p>
在学习如何编写 Emacs Lisp 函数定义之前，花一些时间计算已经编写的各种表达式是很有用的。
这些表达式将是以函数作为其第一个（通常也是唯一的）元素的列表。由于与缓冲区相关的一些函数既简单又有趣，我们将从这些函数开始。
在本节中，我们将计算其中的一些函数。在另一节中，我们将研究其他几个与缓冲区相关的函数的代码，看看它们是如何编写的。
</p>

<ul class="org-ul">
<li><p>
如何求值 <br />
每当你给 Emacs Lisp 一个编辑命令，例如移动光标或滚动屏幕的命令时，你都在对一个表达式求值，
该表达式的第一个元素是一个函数。这就是 Emacs 的工作方式。<br />
</p>

<p>
当你输入按键时，你使 Lisp 解释器评估一个表达式，这就是你得到结果的方式。
即使是输入普通文本也涉及评估一个 Emacs Lisp 函数，在这种情况下，这个函数使用 self-insert-command，
它简单地插入你输入的字符。你通过按键输入来求值的函数被称为交互函数或命令；
如何使一个函数变为交互式将在关于如何编写函数定义的章节中说明。参见“使一个函数变为交互式”。<br />
</p>

<p>
除了输入键盘命令，我们已经看到求值表达式的第二种方法：将光标定位在一个列表后面，然后按 C-x C-e。
这是我们将在本节的其余部分中做的操作。还有其他对表达式求值的方法，我们将在遇到时描述它们。
</p>

<p>
除了用于练习求值之外，接下来的几节中显示的函数本身也非常重要。
学习这些函数可以清楚地区分缓冲区和文件、如何切换到缓冲区以及如何确定缓冲区中的位置。
</p></li>
</ul>
</div>

<div id="outline-container-org6ac70b4" class="outline-3">
<h3 id="org6ac70b4"><span class="section-number-3">2.1.</span> 缓冲区名称</h3>
<div class="outline-text-3" id="text-2-1">
<p>
buffer-name 和 buffer-file-name 这两个函数展示了文件和缓冲区之间的区别。
当你求值以下表达式 (buffer-name) 时，缓冲区的名称会出现在回显区域。
当你求值 (buffer-file-name) 时，缓冲区所指向的文件的名称会出现在回显区域。
通常，(buffer-name) 返回的名称与它所指向的文件的名称相同，而 (buffer-file-name) 返回的是文件的完整路径名。<br />
</p>

<p>
文件和缓冲区是两个不同的实体。文件是计算机中永久记录的信息（除非你删除它）。
另一方面，缓冲区是 Emacs 中的信息，在编辑会话结束时（或当你杀死缓冲区时）会消失。
通常，缓冲区包含你从文件中复制的信息；我们说缓冲区正在访问该文件。你所操作和修改的是这个副本。
对缓冲区的更改不会更改文件，直到你保存缓冲区。当你保存缓冲区时，缓冲区会被复制到文件中，因此被永久保存。<br />
</p>

<p>
如果你在 GNU Emacs 的 Info 模式中阅读此内容，你可以将光标放在每个表达式后面并按 C-x C-e 来对它们求值。
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(buffer-name)

(Buffer-file-name)
</pre>
</div>
<p>
当我在 Info 中执行此操作时，对 (buffer-name) 求值返回的值是 *info*，而对 (buffer-file-name) 求值返回的值是 nil。<br />
</p>

<p>
另一方面，当我编写此文档时，对 (buffer-name) 求值返回的值是 "introduction.texinfo"，
而对 (buffer-file-name) 求值返回的值是 "/gnu/work/intro/introduction.texinfo"。<br />
</p>

<p>
前者是缓冲区的名称，后者是文件的名称。在 Info 中，缓冲区名称是 *info*。Info 没有指向任何文件，
所以对 (buffer-file-name) 求值的结果是 nil。符号 nil 源自拉丁语，意为“无”；在这种情况下，它意味着该缓冲区没有关联到任何文件。
（在 Lisp 中，nil 也用于表示“假”，并且是空列表 () 的同义词。）<br />
</p>

<p>
当我在写作时，我的缓冲区名称是 "introduction.texinfo"。它所指向的文件名称是 "/gnu/work/intro/introduction.texinfo"。<br />
</p>

<p>
（在表达式中，括号告诉 Lisp 解释器将 buffer-name 和 buffer-file-name 作为函数处理；
如果没有括号，解释器会尝试将这些符号作为变量进行求值。参见“变量”。）<br />
</p>

<p>
尽管文件和缓冲区之间存在区别，你常常会发现人们在指代缓冲区时说成文件，反之亦然。
实际上，大多数人会说“我在编辑一个文件”，而不是说“我在编辑一个即将保存到文件的缓冲区”。
从上下文中几乎总能清楚地知道人们的意思。然而，当处理计算机程序时，记住这种区别是很重要的，因为计算机不像人那么聪明。<br />
</p>

<p>
顺便提一下，“缓冲区”一词源自其作为缓冲垫的含义，可以减弱碰撞的冲击力。
在早期的计算机中，缓冲区缓冲了文件与计算机中央处理单元之间的交互。
存放文件的磁鼓或磁带和中央处理单元是两种截然不同的设备，它们以各自的速度间歇地工作。
缓冲区使它们能够有效地协同工作。最终，缓冲区从一个中介、一个临时存储地，发展成为进行工作的地方。
这种转变有点像一个小港口发展成一个大城市：起初它只是一个临时储存货物并等待装船的地方，后来它成为了一个商业和文化中心。<br />
</p>

<p>
并非所有缓冲区都与文件相关联。例如，*scratch* 缓冲区不访问任何文件。同样，*Help* 缓冲区也不与任何文件关联。
</p>

<p>
在早期，如果你没有 ~/.emacs 文件并通过只输入 emacs 命令（而不是指定任何文件）启动一个 Emacs 会话，
Emacs 会以 <b>scratch</b> 缓冲区可见的状态启动。如今，你会看到一个启动画面。
你可以按照启动画面上建议的命令之一操作，访问一个文件，或者按 q 退出启动画面并进入 <b>scratch</b> 缓冲区。<br />
</p>

<p>
如果你切换到 <b>scratch</b> 缓冲区，输入 (buffer-name)，将光标放在它后面，然后按 C-x C-e 来对表达式求值。
返回的名称 <b>scratch</b> 将出现在回显区域中。*scratch* 是缓冲区的名称。
当你在 <b>scratch</b> 缓冲区中输入 (buffer-file-name)`并进行求值时，nil 将会出现在回显区域中，
就像你在 Info 中求值 (buffer-file-name) 时一样。
</p>

<p>
顺便说一下，如果你在 <b>scratch</b> 缓冲区中，希望表达式返回的值出现在 <b>scratch</b> 缓冲区本身而不是回显区域中，
可以输入 C-u C-x C-e 而不是 C-x C-e。这会使返回的值出现在表达式之后。缓冲区看起来会像这样：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(buffer-name)"*Scratch*"
</pre>
</div>
<p>
你不能在 Info 中这样做，因为 Info 是只读的，它不允许你更改缓冲区的内容。
但是，你可以在任何可以编辑的缓冲区中这样做；当你编写代码或文档（例如本书）时，这个功能非常有用。
</p>
</div>
</div>

<div id="outline-container-org2cb144a" class="outline-3">
<h3 id="org2cb144a"><span class="section-number-3">2.2.</span> 获取缓冲区</h3>
<div class="outline-text-3" id="text-2-2">
<p>
buffer-name 函数返回缓冲区的名称；要获取缓冲区本身，则需要使用另一个函数：current-buffer。
如果你在代码中使用这个函数，你将得到的是缓冲区本身。<br />
</p>

<p>
名称和名称所指的对象或实体是不同的。你不是你的名字，你是一个被别人用名字称呼的人。
如果你请求与乔治交谈，而有人递给你一张写有字母“G”、“e”、“o”、“r”、“g”和“e”的卡片，你可能会觉得好笑，但不会满意。
你想交谈的不是名字，而是名字所指的人。缓冲区也是类似的：*scratch* 是 scratch 缓冲区的名称，但名称不是缓冲区本身。
要获取缓冲区本身，你需要使用像 current-buffer 这样的函数。
</p>

<p>
然而，这里有一个小小的复杂之处：如果你在表达式中单独对 current-buffer 求值（如我们在这里将做的那样），
你看到的将是缓冲区名称的打印表示形式，而不是缓冲区的内容。
Emacs 之所以这样工作，有两个原因：缓冲区可能有成千上万行长，太长而不便于显示；
并且另一个缓冲区可能具有相同的内容但名称不同，因此区分它们是很重要的。
</p>

<p>
以下是包含该函数的一个表达式：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(current-buffer)
</pre>
</div>
<p>
如果你在 Emacs 的 Info 中以通常方式对这个表达式求值，#&lt;buffer *info*&gt; 将会出现在回显区域。
这种特殊格式表明返回的是缓冲区本身，而不仅仅是其名称。<br />
</p>

<p>
顺便提一下，虽然你可以在程序中输入数字或符号，但你不能输入缓冲区的打印表示形式：
获取缓冲区本身的唯一方法是使用像 current-buffer 这样的函数。<br />
</p>

<p>
一个相关的函数是 other-buffer。它返回最近选择的、当前缓冲区之外的另一个缓冲区，而不是它名称的打印表示形式。
如果你最近在 <b>scratch</b> 缓冲区之间来回切换，other-buffer 将返回那个缓冲区。<br />
</p>

<p>
你可以通过对以下表达式求值看到这一点：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(other-buffer)
</pre>
</div>
<p>
你应该会看到 #&lt;buffer *scratch*&gt; 出现在回显区域中，或者看到你最近切换回的其他缓冲区的名称。
</p>
</div>
</div>

<div id="outline-container-org82e9612" class="outline-3">
<h3 id="org82e9612"><span class="section-number-3">2.3.</span> 切换缓冲区</h3>
<div class="outline-text-3" id="text-2-3">
<p>
other-buffer 函数在用作需要缓冲区作为参数的函数的参数时，实际上提供了一个缓冲区。
我们可以通过使用 other-buffer 和 switch-to-buffer 来切换到不同的缓冲区，看到这一点。
</p>

<p>
但首先，简要介绍一下 switch-to-buffer 函数。
当你在 Info 和 <b>scratch</b> 缓冲区之间来回切换以求值 (buffer-name) 时，
你很可能按下了 C-x b，然后在 minibuffer 中提示你输入要切换到的缓冲区名称时输入了 *scratch*。
这些按键 C-x b 会使 Lisp 解释器评估交互函数 switch-to-buffer。
正如我们之前所说，这就是 Emacs 的工作方式：不同的按键调用或运行不同的函数。
例如，C-f 调用 forward-char，M-e 调用 `forward-sentence`，等等。
</p>

<p>
通过在表达式中写出 switch-to-buffer 并提供一个要切换到的缓冲区，我们可以像 C-x b 那样切换缓冲区：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(switch-to-buffer (other-buffer))
</pre>
</div>
<p>
switch-to-buffer 符号是列表的第一个元素，因此 Lisp 解释器会将其视为一个函数，并执行与之相关的指令。
但在此之前，解释器会注意到 other-buffer 在括号内，并先对该符号进行处理。
other-buffer 是该列表的第一个（在此情况下也是唯一的）元素，因此 Lisp 解释器会调用或运行该函数，它将返回另一个缓冲区。
接下来，解释器运行 switch-to-buffer，并将返回的另一个缓冲区作为参数传递给它，这就是 Emacs 将要切换到的缓冲区。
如果你在 Info 中阅读此内容，现在就试试。对这个表达式求值。（要返回原缓冲区，请键入 C-x b RET。）<br />
</p>

<p>
在本文件后续章节的编程示例中，你会更常看到 set-buffer 函数，而不是 switch-to-buffer。
这是因为计算机程序和人类之间存在差异：人类有眼睛，期望在计算机终端上看到自己正在处理的缓冲区。
这显而易见，几乎不言自明。然而，程序没有眼睛。当计算机程序处理缓冲区时，该缓冲区不需要在屏幕上可见。<br />
</p>

<p>
switch-to-buffer 是为人类设计的，它做了两件事：它切换 Emacs 的注意力指向的缓冲区，并在窗口中将显示的缓冲区切换到新缓冲区。
而 set-buffer 只做一件事：它将计算机程序的注意力切换到另一个缓冲区。
屏幕上的缓冲区保持不变（当然，通常在命令运行完成之前那里不会发生任何变化）。<br />
</p>

<p>
另外，我们刚刚引入了另一个术语，即“调用”（call）。当你评估一个列表时，其中的第一个符号是一个函数，你就是在调用那个函数。
这个术语的使用源于将函数视为一个可以为你做某事的实体——就像水管工是一个你可以打电话给他或她修理漏水的实体一样。
</p>
</div>
</div>

<div id="outline-container-org2786da1" class="outline-3">
<h3 id="org2786da1"><span class="section-number-3">2.4.</span> 缓冲区大小和点的位置</h3>
<div class="outline-text-3" id="text-2-4">
<p>
最后，让我们来看几个相对简单的函数：buffer-size、point、point-min 和 point-max。
这些函数提供了有关缓冲区大小以及光标在其中位置的信息。<br />
</p>

<p>
buffer-size 函数告诉你当前缓冲区的大小；即，该函数返回缓冲区中字符的数量。
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(buffer-size)
</pre>
</div>
<p>
你可以通过将光标定位在表达式之后并按 C-x C-e 的通常方式来评估它。<br />
</p>

<p>
在 Emacs 中，光标的当前位置称为“点”（point）。表达式 (point) 返回一个数字，表示从缓冲区开头到光标所在位置的字符数量。
</p>

<p>
你可以通过以通常方式评估以下表达式，查看当前缓冲区中点的字符计数：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(point)
</pre>
</div>
<p>
在我写下这些内容时，point 的值是 65724。point 函数在本书后面的一些示例中经常使用。<br />
</p>

<p>
point 的值当然取决于它在缓冲区中的位置。如果你在这个位置对 point 求值，那么该数值会更大：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(point)
</pre>
</div>

<p>
对我来说，point 在此位置的值是 66043，这意味着两个表达式之间有 319 个字符（包括空格）。
（毫无疑问，你会看到不同的数字，因为在我第一次 point 求值之后，我已经对内容进行了编辑。）<br />
</p>

<p>
point-min 函数与 point 类似，但它返回当前缓冲区中 point 的最小允许值。这个值通常是 1，除非启用了“缩小”功能。
（缩小是一种机制，通过它你可以限制自己或程序只在缓冲区的一部分进行操作。详见“缩小和扩展”部分。）
同样，point-max 函数返回当前缓冲区中 point 的最大允许值。
</p>
</div>
</div>

<div id="outline-container-org7621ac5" class="outline-3">
<h3 id="org7621ac5"><span class="section-number-3">2.5.</span> 练习</h3>
<div class="outline-text-3" id="text-2-5">
<p>
找到一个你正在处理的文件，并移至其中间位置。找出该文件的缓冲区名称、文件名、长度以及你在文件中的位置。
</p>
</div>
</div>
</div>


<div id="outline-container-org9dc648f" class="outline-2">
<h2 id="org9dc648f"><span class="section-number-2">3.</span> 如何编写函数定义</h2>
<div class="outline-text-2" id="text-3">
<p>
当 Lisp 解释器对一个列表进行求值时，它会查看该列表的第一个符号是否附有一个函数定义；换句话说，即该符号是否指向一个函数定义。
如果是，计算机就会执行定义中的指令。一个附有函数定义的符号简单地被称为“函数”（虽然严格来说，函数是定义本身，而符号是对它的引用）。
</p>

<ul class="org-ul">
<li><p>
关于原始函数的说明 <br />
所有函数都是用其他函数定义的，除了少数用C编程语言编写的原始函数。
当你编写函数的定义时，你会在Emacs Lisp中编写它们，并使用其他函数作为构建块。
你使用的一些函数本身会用Emacs Lisp编写（可能是你自己写的），而有些则是用C编写的原始函数。
原始函数的用法和用Emacs Lisp编写的函数完全相同，并且表现也相似。
它们之所以用C编写，是为了使GNU Emacs能够在任何具有足够性能并能运行C语言的计算机上轻松运行。<br />
</p>

<p>
让我再强调一下这一点：当你用Emacs Lisp编写代码时，你不会区分使用C语言编写的函数和使用Emacs Lisp编写的函数。
区别是无关紧要的。我之所以提到这个区别，只是因为知道它是很有趣的。
实际上，除非你深入研究，否则你不会知道一个已编写的函数是用Emacs Lisp编写的还是用C编写的。
</p></li>
</ul>
</div>

<div id="outline-container-org63b63bf" class="outline-3">
<h3 id="org63b63bf"><span class="section-number-3">3.1.</span> defun 宏</h3>
<div class="outline-text-3" id="text-3-1">
<p>
在 Lisp 中，像 mark-whole-buffer 这样的符号有与之关联的代码，用来告诉计算机在调用该函数时该做什么。
这段代码称为函数定义，它是通过符号 defun（"define function" 的缩写）开头的 Lisp 表达式创建的。<br />
</p>

<p>
在接下来的章节中，我们将查看来自 Emacs 源代码的函数定义，例如 mark-whole-buffer。
在本节中，我们将描述一个简单的函数定义，以便你了解它的样子。这个函数定义使用了算术运算，因为这使得例子更简单。
一些人不喜欢使用算术运算的例子；然而，如果你是这样的人，不必担心。
在本介绍的其余部分，我们研究的代码几乎不涉及算术或数学。这些例子大多以某种方式涉及文本。<br />
</p>

<p>
一个函数定义在 defun 之后最多有五个部分：
</p>
<ol class="org-ol">
<li>该函数定义应附加到的符号名称。</li>
<li>将传递给函数的参数列表。如果没有参数将传递给函数，这就是一个空列表 ()。</li>
<li>描述该函数的文档。（技术上是可选的，但强烈推荐。）</li>
<li>可选地，一个表达式，使函数可交互，这样你可以通过输入 M-x 然后函数名称，或者按下适当的键或组合键来使用它。</li>
<li>指示计算机该怎么做的代码：函数定义的主体。</li>
</ol>

<p>
将函数定义的五个部分想象成一个模板，其中每个部分都有一个插槽，这样会更有帮助。
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun function-name (arguments…)
  "optional-documentation…"
  (interactive argument-passing-info)     ;可选的
  body…)
</pre>
</div>
<p>
作为示例，以下是一个将其参数乘以 7 的函数代码。
（这个例子不是交互式的。关于如何使函数变得交互式，请参见“使函数变得交互式”的相关信息。）
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun multiply-by-seven (number)
  "Multiply NUMBER by seven."
  (* 7 number))
</pre>
</div>
<p>
这个定义以一个括号和符号 defun 开头，接着是函数的名称。<br />
</p>

<p>
函数名称之后是一个包含将传递给函数的参数的列表，这个列表称为参数列表。
在这个例子中，列表只有一个元素：符号 number。当函数被使用时，这个符号将绑定到作为函数参数的值。
</p>

<p>
作为参数的名称，我本可以选择其他名字，而不是用 number 这个词。例如，我可以选择 multiplicand（被乘数）。
我选择“number”这个词是因为它表明了这个位置的值应该是什么类型的；
但我同样可以选择“multiplicand”这个词，来表示放在这个位置的值在函数工作中的作用。
我甚至可以叫它 foogle，但那会是个糟糕的选择，因为它不会告诉人们它的含义。
参数名称的选择取决于程序员，应该选择一个能使函数含义明确的名字。<br />
</p>

<p>
实际上，你可以为参数列表中的符号选择任何名称，甚至是某个其他函数中使用的符号名称：你在参数列表中使用的名称是该定义所私有的。
在该定义中，这个名称指的是不同于函数定义外部任何使用相同名称的实体。
假设你在家人中有一个昵称叫“Shorty”；当你的家人提到“Shorty”时，他们指的是你。
但在你的家人之外，例如在电影中，“Shorty”这个名字可能指的是其他人。
由于参数列表中的名称对于函数定义来说是私有的，你可以在函数体内更改该符号的值，而不会更改其在函数外部的值。
其效果类似于 let 表达式产生的效果。（参见 let。）
</p>

<p>
参数列表之后是描述函数的文档字符串。这是当你输入 C-h f 和函数名称时看到的内容。
顺便提一下，当你编写这样的文档字符串时，应该使第一行成为一个完整的句子，因为有些命令（如 apropos）只打印多行文档字符串的第一行。
此外，如果文档字符串有第二行，你不应该缩进它，因为在使用 C-h f (describe-function) 时，这样会显得不协调。
虽然文档字符串是可选的，但它非常有用，几乎应该包含在你编写的每一个函数中。<br />
</p>

<p>
例子的第三行是函数定义的主体。（当然，大多数函数的定义比这个要长得多。）
在这个函数中，主体是列表 (* 7 number)，它表示将 number 的值乘以 7。
（在 Emacs Lisp 中，* 是乘法函数，就像 + 是加法函数一样。）<br />
</p>

<p>
当你使用 multiply-by-seven 函数时，参数 number 将被求值为你想要使用的实际数字。
下面是一个展示如何使用 multiply-by-seven 的例子；不过，暂时不要尝试对其求值！
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(multiply-by-seven 3)
</pre>
</div>
<p>
在实际使用该函数时，在下一节的函数定义中指定的符号 number 被绑定到值 3。
请注意，虽然在函数定义中 number 在括号内，但传递给 multiply-by-seven 函数的参数不是在括号内。
括号在函数定义中被写出是为了让计算机能识别参数列表的结束位置和函数定义其余部分的开始位置。<br />
</p>

<p>
如果你对这个例子求值，你很可能会得到一个错误消息。
（不妨试试看！）这是因为我们已经编写了函数定义，但还没有告诉计算机这个定义——我们还没有在 Emacs 中加载函数定义。
安装函数的过程就是告诉 Lisp 解释器函数的定义。安装的过程将在下一节中介绍。
</p>
</div>
</div>

<div id="outline-container-orge6bf513" class="outline-3">
<h3 id="orge6bf513"><span class="section-number-3">3.2.</span> 安装函数定义</h3>
<div class="outline-text-3" id="text-3-2">
<p>
如果你正在 Emacs 的 Info 模式中阅读本文，可以通过先对函数定义求值，
然后再对 (multiply-by-seven 3) 求值来试用 multiply-by-seven 函数。以下是函数定义的副本。
将光标放在函数定义的最后一个括号之后，然后按 C-x C-e。这样做时，multiply-by-seven 会出现在回显区域。
（这意味着，当对函数定义求值时，它返回的值是被定义的函数的名称。）同时，这个操作会安装函数定义。
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun multiply-by-seven (number)
  "Multiply NUMBER by seven."
  (* 7 number))
</pre>
</div>
<p>
通过对这个 defun 求值，你刚刚在 Emacs 中安装了 multiply-by-seven。
现在，这个函数和 forward-word 或任何其他你使用的编辑函数一样，已经成为 Emacs 的一部分了。
（multiply-by-seven 将一直保持安装状态，直到你退出 Emacs。
要了解如何在每次启动 Emacs 时自动重新加载代码，请参阅“永久安装代码”。）
</p>
</div>

<div id="outline-container-orgbc8d9f4" class="outline-4">
<h4 id="orgbc8d9f4"><span class="section-number-4">3.2.1.</span> 安装的效果</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
你可以通过对以下示例求值来查看安装 multiply-by-seven 的效果。
将光标放在以下表达式之后，然后按 C-x C-e。数字 21 将出现在回显区域。
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(Multiply-by-seven 3)
</pre>
</div>
<p>
如果你愿意，可以通过输入 C-h f (describe-function)，然后输入函数名 multiply-by-seven 来查看该函数的文档。
这样做时，屏幕上会出现一个 Help 窗口，上面显示：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">multiply-by-seven is a Lisp function.

(multiply-by-seven NUMBER)

Multiply NUMBER by seven.
</pre>
</div>
<p>
（要返回屏幕上的单窗口显示，输入 C-x 1。）
</p>
</div>
</div>

<div id="outline-container-org1e13556" class="outline-4">
<h4 id="org1e13556"><span class="section-number-4">3.2.2.</span> 修改函数定义</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
如果你想更改 multiply-by-seven 的代码，只需重写它即可。要用新版本替换旧版本，只需再次对函数定义求值。
这就是在 Emacs 中修改代码的方式，非常简单。<br />
</p>

<p>
例如，你可以将 multiply-by-seven 函数更改为将数字自身相加七次，而不是将数字乘以七。
这样做会通过不同的方式产生相同的答案。同时，我们还会在代码中添加一条注释；
注释是 Lisp 解释器忽略的文本，但可能对人类读者有用或有启发。注释指出这是第二个版本。<br />
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun multiply-by-seven (number)       ; 第二个版本。
  "Multiply NUMBER by seven."
  (+ number number number number number number number))
</pre>
</div>
<p>
注释位于分号 ; 之后。在 Lisp 中，分号后面的一行内容都是注释。行尾就是注释的结束。
如果要将注释扩展到两行或更多行，每行都要以分号开头。<br />
</p>

<p>
关于注释的更多信息，请参见《GNU Emacs Lisp参考手册》中的“编写 .emacs 文件”和“注释”部分。<br />
</p>

<p>
你可以通过对这个版本的 multiply-by-seven 函数求值来安装它，
方法与对第一个函数求值的方式相同：将光标放在最后一个括号之后，然后按 C-x C-e。<br />
</p>

<p>
总之，这就是在 Emacs Lisp 中编写代码的方法：编写一个函数，安装它，测试它，然后进行修复或改进并再次安装。
</p>
</div>
</div>
</div>

<div id="outline-container-org13886c2" class="outline-3">
<h3 id="org13886c2"><span class="section-number-3">3.3.</span> 使函数具有交互性</h3>
<div class="outline-text-3" id="text-3-3">
<p>
你可以通过在文档之后紧接着放置一个以特殊形式 interactive 开头的列表来使一个函数具有交互性。
用户可以通过键入 M-x 然后输入函数名称来调用一个交互函数；或者通过键入与其绑定的快捷键来调用，
例如，键入 C-n 调用 next-line 或 C-x h 调用 mark-whole-buffer。
</p>

<p>
有趣的是，当你以交互方式调用一个交互函数时，返回的值不会自动显示在回显区域。
这是因为你通常调用一个交互函数是为了它的副作用，比如向前移动一个单词或一行，而不是为了它的返回值。
如果每次按键时返回的值都显示在回显区域，那将会非常分散注意力。
</p>
</div>

<div id="outline-container-org3133a5b" class="outline-4">
<h4 id="org3133a5b"><span class="section-number-4">3.3.1.</span> 交互式的 multiply-by-seven：概述</h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
通过创建一个交互版本的 multiply-by-seven 函数，可以说明特殊形式 interactive 的使用方法，以及如何在回显区显示一个值。<br />
</p>

<p>
代码如下：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun multiply-by-seven (number)       ; 交互版本。
  "将 NUMBER 乘以七。"
  (interactive "p")
  (message "结果是 %d" (* 7 number)))
</pre>
</div>
<p>
您可以通过将光标放置在代码之后并输入 C-x C-e 来安装此代码。函数名称将显示在回显区中。
然后，您可以输入 C-u 和一个数字，再输入 M-x multiply-by-seven 并按下 RET 键来使用该代码。
短语 “The result is &#x2026;”（结果是&#x2026;）以及相应的乘积将出现在回显区中。<br />
</p>

<p>
更一般地说，您可以通过以下两种方式调用这样的函数：
</p>
<ol class="org-ol">
<li>输入包含要传递数字的前缀参数，然后输入 M-x 和函数名，例如 C-u 3 M-x forward-sentence</li>
<li>输入函数绑定的按键或按键组合，例如 C-u 3 M-e。</li>
</ol>

<p>
以上两个示例的效果相同，都是将光标向前移动三个句子。（由于 multiply-by-seven 没有绑定到按键，因此不能用作按键绑定的示例。）<br />
</p>

<p>
（请参阅 “按键绑定”，了解如何将命令绑定到按键。）<br />
</p>

<p>
可以通过按下 META 键然后输入一个数字（例如 M-3 M-e），或者按下 C-u 然后输入一个数字（例如 C-u 3 M-e），
将前缀参数传递给交互式函数（如果只输入 C-u 而没有数字，则默认值为 4）。
</p>
</div>
</div>

<div id="outline-container-orgcba5747" class="outline-4">
<h4 id="orgcba5747"><span class="section-number-4">3.3.2.</span> 一个交互的乘以七函数</h4>
<div class="outline-text-4" id="text-3-3-2">
<p>
让我们看看特殊形式 interactive 的用法，然后看一下 multiply-by-seven 函数的交互版本中的 message 函数。
你可能记得函数定义如下所示：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun multiply-by-seven (number)       ; 交互版本。
  "将 NUMBER 乘以七。"
  (interactive "p")
  (message "结果是 %d" (* 7 number)))
</pre>
</div>
<p>
在这个函数中，表达式 (interactive "p") 是一个包含两个元素的列表。"p" 告诉 Emacs 将前缀参数传递给函数，并将其值用于函数的参数。<br />
</p>

<p>
这个参数将是一个数字。这意味着符号 number 将在以下这一行中绑定到一个数字：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(message "结果是 %d" (* 7 number))
</pre>
</div>
<p>
例如，如果你的前缀参数是 5，Lisp 解释器将像下面这样计算这一行：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(message "结果是 %d" (* 7 5))
</pre>
</div>
<p>
（如果你在 GNU Emacs 中阅读此内容，可以自己计算这个表达式。）首先，解释器将计算内部列表，即 (* 7 5)。
这会返回一个值 35。接着，它将计算外部列表，把列表的第二个及后续元素的值传递给 message 函数。<br />
</p>

<p>
正如我们所见，message 是一个 Emacs Lisp 函数，专为向用户发送单行消息而设计。
（请参见 message 函数。）总的来说，message 函数会将其第一个参数按原样打印在回显区，
除了 %d 或 %s 的出现（以及其他我们尚未提到的各种 % 开头的序列）。
当它遇到一个控制序列时，函数会查看第二个或后续参数，并在字符串中控制序列所在的位置打印该参数的值。<br />
</p>

<p>
在交互的 multiply-by-seven 函数中，控制字符串是 %d，它要求一个数字，而通过计算 (* 7 5) 返回的值是数字 35。
因此，数字 35 会被打印在 %d 的位置，消息内容为 “The result is 35”。<br />
</p>

<p>
（注意，当你调用 multiply-by-seven 函数时，消息是直接打印的，没有引号；但当你调用 message 函数时，文本会以双引号打印。
这是因为当你计算一个其第一个元素是 message 的表达式时，message 返回的值会显示在回显区；
但当 message 嵌入在函数中时，它作为一个副作用打印文本而不带引号。）
</p>
</div>
</div>
</div>

<div id="outline-container-orge53b1d1" class="outline-3">
<h3 id="orge53b1d1"><span class="section-number-3">3.4.</span> interactive 的不同选项</h3>
<div class="outline-text-3" id="text-3-4">
<p>
在示例中，multiply-by-seven 使用 "p" 作为 interactive 的参数。
这个参数告诉 Emacs 将你输入的 C-u 后跟一个数字，或 META 后跟一个数字解释为将该数字作为参数传递给函数的命令。
Emacs 预定义了超过二十个字符用于 interactive。在几乎每种情况下，这些选项中的一个将使你能够以交互方式向函数传递正确的信息。
（请参阅《GNU Emacs Lisp 参考手册》中的 "Code Characters for interactive"。）<br />
</p>

<p>
考虑函数 zap-to-char。它的 interactive 表达式是：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(interactive "p\ncZap to char: ")
</pre>
</div>
<p>
interactive 参数的第一部分是你已经熟悉的 p。该参数告诉 Emacs 将前缀解释为要传递给函数的数字。
你可以通过输入 C-u 后跟一个数字或输入 META 后跟一个数字来指定前缀。前缀是指定字符的数量。
因此，如果你的前缀是 3，指定的字符是 x，那么你将删除直到第三个 x（包括它）之前的所有文本。
如果不设置前缀，则删除直到指定字符（包括它）之前的所有文本。<br />
</p>

<p>
c 告诉函数要删除的字符的名称。<br />
</p>

<p>
更正式地说，一个具有两个或多个参数的函数可以通过将部分添加到 interactive 后面的字符串中，将信息传递给每个参数。
当你这样做时，信息按照在 interactive 列表中指定的顺序传递给每个参数。在字符串中，每个部分由 \n（换行符）分隔开。
例如，你可以在 p 后面加上一个 \n 和 cZap to char: 。这会使 Emacs 传递前缀参数的值（如果有）和字符。<br />
</p>

<p>
在这种情况下，函数定义如下所示，其中 arg 和 char 是 interactive 绑定前缀参数和指定字符的符号：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun name-of-function (arg char)
  "文档……"
  (interactive "p\ncZap to char: ")
  函数主体……
)
</pre>
</div>
<p>
（在提示符中的冒号后加上空格，使提示看起来更好。参见 copy-to-buffer 的定义示例。）<br />
</p>

<p>
当一个函数不需要参数时，interactive 也不需要参数。这样的函数包含一个简单的表达式 (interactive)。
mark-whole-buffer 函数就是这样的例子。<br />
</p>

<p>
另外，如果这些特殊的字母代码不适合你的应用，你可以将自己的参数作为列表传递给 interactive。<br />
</p>

<p>
参见 append-to-buffer 的定义示例。有关此技术的更完整解释，请参阅《GNU Emacs Lisp 参考手册》中的 "Using Interactive"。
</p>
</div>
</div>

<div id="outline-container-orgfbd181e" class="outline-3">
<h3 id="orgfbd181e"><span class="section-number-3">3.5.</span> 永久安装代码</h3>
<div class="outline-text-3" id="text-3-5">
<p>
当你通过计算函数定义来安装它时，该函数将一直保持安装状态，直到你退出 Emacs。
下次你启动一个新的 Emacs 会话时，该函数将不会被安装，除非你再次计算函数定义。<br />
</p>

<p>
在某个时候，你可能希望每次启动 Emacs 新会话时自动安装代码。你可以通过以下几种方法实现：
</p>
<ul class="org-ul">
<li>如果你有仅供自己使用的代码，可以将函数定义的代码放在 .emacs 初始化文件中。当你启动 Emacs 时，.emacs 文件会自动计算，文件中的所有函数定义都会被安装。参见 "Your .emacs File"。</li>
<li>或者，你可以将需要安装的函数定义放在一个或多个文件中，并使用 load 函数让 Emacs 计算这些文件，从而安装其中的每个函数。参见 "Loading Files"。</li>
<li>第三，如果你有供整个站点使用的代码，通常将其放在一个名为 site-init.el 的文件中，该文件在构建 Emacs 时被加载。这使得所有使用你的机器的人都可以使用这些代码。（参见 Emacs 发行版中的 INSTALL 文件。）</li>
</ul>

<p>
最后，如果你有代码希望所有 Emacs 用户都能使用，你可以将其发布在计算机网络上，或将副本发送给自由软件基金会。
（当你这样做时，请将代码及其文档在允许他人运行、复制、研究、修改和再分发代码的许可证下发布，并保护自己不被剥夺你的工作成果。）
如果你将代码副本发送给自由软件基金会，并正确保护自己和他人，这些代码可能会被包含在 Emacs 的下一个版本中。
在很大程度上，Emacs 在过去的几年中就是通过这样的捐赠逐步扩展的。
</p>
</div>
</div>

<div id="outline-container-orgd4f7be6" class="outline-3">
<h3 id="orgd4f7be6"><span class="section-number-3">3.6.</span> let</h3>
<div class="outline-text-3" id="text-3-6">
<p>
let 表达式是 Lisp 中的一种特殊形式，在大多数函数定义中你都需要使用它。<br />
</p>

<p>
let 用于将一个符号附加或绑定到一个值上，这样 Lisp 解释器就不会将变量与另一个不属于该函数的同名变量混淆。<br />
</p>

<p>
要理解为什么需要 let 这种特殊形式，可以考虑你拥有一所房子的情况，你通常称之为“the house”，
例如在这句话中：“The house needs painting.” 如果你在拜访朋友时，你的主人提到“the house”，
他很可能指的是他自己的房子，而不是你的，也就是说，是指另一所房子。<br />
</p>

<p>
如果你的朋友指的是他自己的房子，而你以为他指的是你的房子，这就可能引发混淆。
在 Lisp 中也可能发生同样的情况：如果一个函数内部使用的变量与另一个函数内部使用的变量同名，
而这两个变量并不打算表示相同的值，那么可能会导致混淆。let 特殊形式可以防止这种混淆。
</p>
</div>

<div id="outline-container-orgaec005a" class="outline-4">
<h4 id="orgaec005a"><span class="section-number-4">3.6.1.</span> let 防止混淆</h4>
<div class="outline-text-4" id="text-3-6-1">
<p>
let 特殊形式可以防止混淆。let 为局部变量创建一个名称，
遮蔽在 let 表达式之外对相同名称的任何使用（在计算机科学术语中，这称为“绑定变量”）。
这就像理解在你主人的家中，每当他提到“the house”时，他指的是他的房子，而不是你的房子。
（用于命名函数参数的符号也以完全相同的方式绑定为局部变量。参见 defun 宏。）<br />
</p>

<p>
另一种理解 let 的方式是，它在你的代码中定义了一个特殊的区域：在 let 表达式的主体内部，你命名的变量有其自己的局部意义。
在 let 主体之外，它们有其他的意义（或者可能根本没有定义）。
这意味着在 let 主体内部，为 let 表达式命名的变量调用 setq 会设置该名称的局部变量的值。
然而，在 let 主体之外（例如，在调用另一个地方定义的函数时），为 let 表达式命名的变量调用 setq 不会影响该局部变量。<br />
</p>

<p>
let 可以一次创建多个变量。同时，let 为其创建的每个变量赋予一个初始值，该初始值可以是你指定的值或 nil。
（在术语中，这称为将变量绑定到一个值。）在 let 创建并绑定了变量之后，它会执行 let 主体中的代码，
并将主体中最后一个表达式的值作为整个 let 表达式的值返回。
（“执行”是一个术语，意味着计算一个列表；它来自该词的含义“付诸实际效果”（《牛津英语词典》）。
因为你计算一个表达式来执行一个动作，“执行”已经演变为“计算”的同义词。）
</p>
</div>
</div>

<div id="outline-container-orgd9429f7" class="outline-4">
<h4 id="orgd9429f7"><span class="section-number-4">3.6.2.</span> let 表达式的部分</h4>
<div class="outline-text-4" id="text-3-6-2">
<p>
let 表达式由三个部分组成。第一部分是符号 let。第二部分是一个列表，称为 varlist，其中的每个元素要么是单独的符号，
要么是一个包含两个元素的列表，其中第一个元素是一个符号。let 表达式的第三部分是 let 的主体。主体通常由一个或多个列表组成。<br />
</p>

<p>
let 表达式的模板如下所示：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(let varlist body…)
</pre>
</div>
<p>
varlist 中的符号是通过 let 特殊形式赋予初始值的变量。
单独的符号初始值为 nil；每个作为两个元素列表的第一个元素的符号被绑定到 Lisp 解释器在评估第二个元素时返回的值。<br />
</p>

<p>
因此，varlist 可能如下所示：(thread (needles 3))。
在这种情况下，在一个 let 表达式中，Emacs 将符号 thread 绑定到初始值 nil，并将符号 needles 绑定到初始值 3。<br />
</p>

<p>
当你编写一个 let 表达式时，你需要将相应的表达式放入 let 表达式模板的各个位置。<br />
</p>

<p>
如果 varlist 由两个元素的列表组成（通常是这种情况），则 let 表达式的模板如下所示：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(let ((variable value)
    (variable value)
    …)
body…)
</pre>
</div>
</div>
</div>

<div id="outline-container-orga8e1b1e" class="outline-4">
<h4 id="orga8e1b1e"><span class="section-number-4">3.6.3.</span> 示例 let 表达式</h4>
<div class="outline-text-4" id="text-3-6-3">
<p>
以下表达式创建了两个变量 zebra 和 tiger 并赋予它们初始值。let 表达式的主体是一个调用 message 函数的列表。
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(let ((zebra "stripes")
      (tiger "fierce"))
  (message "One kind of animal has %s and another is %s."
           zebra tiger))
</pre>
</div>
<p>
这里，varlist 是 ((zebra "stripes") (tiger "fierce"))。<br />
</p>

<p>
两个变量分别是 zebra 和 tiger。每个变量是一个包含两个元素的列表的第一个元素，每个值是其两个元素列表的第二个元素。
在 varlist 中，Emacs 将变量 zebra 绑定到值 "stripes"，并将变量 tiger 绑定到值 "fierce"。
在这个例子中，这两个值都是字符串。值也可以是另一个列表或一个符号。let 的主体紧跟在保存变量的列表之后。
在这个例子中，主体是一个使用 message 函数在回显区域打印字符串的列表。<br />
</p>

<p>
你可以按照通常的方式来求值这个例子，将光标放在最后一个括号后面，然后键入 C-x C-e。当你这样做时，回显区域中会出现以下内容：
</p>
<div class="org-src-container">
<pre class="src src-shell">"One kind of animal has stripes and another is fierce."
</pre>
</div>
<p>
正如我们之前看到的，message 函数打印其第一个参数，除了 %s 以外。
在这个例子中，变量 zebra 的值在第一个 %s 的位置打印，变量 tiger 的值在第二个 %s 的位置打印。<br />
</p>
</div>
</div>

<div id="outline-container-org0b51f5c" class="outline-4">
<h4 id="org0b51f5c"><span class="section-number-4">3.6.4.</span> 在 let 语句中的未初始化变量</h4>
<div class="outline-text-4" id="text-3-6-4">
<p>
如果你在 let 语句中没有将变量绑定到特定的初始值，它们将自动绑定到 nil 作为初始值，如下面的表达式所示：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(let ((birch 3)
      pine
      fir
      (oak 'some))
  (message
   "Here are %d variables with %s, %s, and %s value."
   birch pine fir oak))
</pre>
</div>
<p>
这里，varlist 是 ((birch 3) pine fir (oak 'some))。<br />
</p>

<p>
如果你以通常的方式对这个表达式求值，在回显区域中会出现以下内容：
</p>
<div class="org-src-container">
<pre class="src src-shell">"Here are 3 variables with nil, nil, and some value."
</pre>
</div>
<p>
在这个例子中，Emacs 将符号 birch 绑定到数字 3，将符号 pine 和 fir 绑定到 nil，并将符号 oak 绑定到值 some。<br />
</p>

<p>
请注意，在 let 的第一部分中，变量 pine 和 fir 单独作为原子存在，未被括号包围；这是因为它们被绑定到 nil（空列表）。
但 oak 被绑定到 some，因此它是列表 (oak 'some) 的一部分。同样地，birch 被绑定到数字 3，因此它在一个包含该数字的列表中。
（由于数字自我求值，不需要引用它。此外，数字在消息中使用 %d 而不是 %s 进行打印。）
这四个变量作为一个整体被放入一个列表中，以将它们与 let 的主体部分区分开来。
</p>
</div>
</div>

<div id="outline-container-org7c4b0ea" class="outline-4">
<h4 id="org7c4b0ea"><span class="section-number-4">3.6.5.</span> let 如何绑定变量</h4>
<div class="outline-text-4" id="text-3-6-5">
<p>
Emacs Lisp 支持两种将变量名称绑定到其值的方式。这些方式决定了特定绑定在程序的哪些部分是有效的。
由于历史原因，Emacs Lisp 默认使用一种称为动态绑定（dynamic binding）的变量绑定形式。
然而，在本手册中，我们讨论的是另一种更为推荐的绑定形式，称为词法绑定（lexical binding），除非另有说明。
（未来，Emacs 的维护者计划将默认绑定方式更改为词法绑定）。如果你以前使用过其他编程语言，你可能已经熟悉词法绑定的行为方式。<br />
</p>

<p>
为了在程序中使用词法绑定，你应当在 Emacs Lisp 文件的第一行添加以下内容：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; -*- lexical-binding: t -*-
</pre>
</div>
<p>
关于这方面的更多信息，请参阅《The Emacs Lisp Reference Manual》中的“Variable Scoping”章节。
</p>
</div>

<ol class="org-ol">
<li><a id="org57b079e"></a>词法绑定和动态绑定的区别<br />
<div class="outline-text-5" id="text-3-6-5-1">
<p>
如我们之前讨论的那样（参见《let 防止混淆》），在词法绑定下使用 let 创建局部变量时，这些变量仅在 let 表达式的主体中有效。
在代码的其他部分，它们具有其他含义，因此，如果你在 let 主体中调用了在其他地方定义的函数，该函数将无法“看到”你所创建的局部变量。
（另一方面，如果你调用的是在 let 主体中定义的函数，该函数将能够看到并修改来自该 let 表达式的局部变量。）<br />
</p>

<p>
在动态绑定下，规则不同：当你使用 let 时，你创建的局部变量在 let 表达式的执行期间有效。
这意味着，如果你的 let 表达式调用了一个函数，无论该函数定义在何处（包括在完全不同的文件中），该函数都能看到这些局部变量。<br />
</p>

<p>
另一种思考动态绑定下 let 的方式是，每个变量名都有一个全局的“栈”绑定，每当你使用该变量名时，它都会引用栈顶的绑定。
（你可以将其想象为桌子上的一叠写有值的纸张。）当你使用 let 动态绑定一个变量时，
它会将你指定的新绑定放在栈顶，然后执行 let 的主体。一旦 let 主体执行完毕，它会将该绑定从栈中移除，显示出下方的绑定。<br />
</p>
</div>
</li>

<li><a id="org4043423"></a>词法绑定与动态绑定的示例<br />
<div class="outline-text-5" id="text-3-6-5-2">
<p>
在某些情况下，词法绑定和动态绑定的行为是相同的。但是，在其他情况下，它们可能会改变程序的含义。
例如，看看在词法绑定下，这段代码会发生什么：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; -*- lexical-binding: t -*-

(setq x 0)

(defun getx ()
  x)

(setq x 1)

(let ((x 2))
  (getx))
     ⇒ 1
</pre>
</div>
<p>
在这里，(getx) 的结果是 1。在词法绑定下，getx 看不到我们 let 表达式中的值。
这是因为 getx 的主体在我们的 let 表达式主体之外。
由于 getx 是在我们代码的最顶层全局定义的（即，不是在任何 `let` 表达式的主体内定义的），它在全局范围内查找并找到了 x。
在执行 getx 时，x 的当前全局值是 1，所以 getx 返回的也是 1。<br />
</p>

<p>
如果我们使用动态绑定，那么行为就会不同：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">;;; -*- lexical-binding: nil -*-

(setq x 0)

(defun getx ()
  x)

(setq x 1)

(let ((x 2))
  (getx))
     ⇒ 2
</pre>
</div>
<p>
现在，(getx) 的结果是 2！这是因为在动态绑定下，当执行 getx 时，栈顶的 x 绑定来自我们的 let 表达式。
这一次，getx 看不到全局的 x 值，因为在绑定的栈中，全局绑定位于 let 表达式的绑定之下。<br />
</p>

<p>
（有些变量也是“特殊”的，即使在 lexical-binding 为 t 的情况下，它们也总是动态绑定的。参见“使用 defvar 初始化变量”。）
</p>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-orgbbabca4" class="outline-3">
<h3 id="orgbbabca4"><span class="section-number-3">3.7.</span> if 特殊形式</h3>
<div class="outline-text-3" id="text-3-7">
<p>
另一个特殊形式是条件 if。这种形式用于指示计算机做出决策。
你可以在不使用 if 的情况下编写函数定义，但由于它的使用频率足够高且重要性足够大，所以在这里包含它。
例如，它在函数 beginning-of-buffer 的代码中被使用。<br />
</p>

<p>
if 的基本概念是，如果一个测试为真，则计算一个表达式；如果测试不为真，则不计算该表达式。
例如，你可能会做出这样的决策：“如果天气温暖且阳光明媚，那么去海滩！”
</p>
</div>

<div id="outline-container-org72bcc79" class="outline-4">
<h4 id="org72bcc79"><span class="section-number-4">3.7.1.</span> 更详细地看 if</h4>
<div class="outline-text-4" id="text-3-7-1">
<p>
在 Lisp 中编写的 if 表达式不使用单词 "then"；测试和动作是列表的第二和第三个元素，其第一个元素是 if。
尽管如此，if 表达式的测试部分通常称为 if 部分，第二个参数通常称为 then 部分。<br />
</p>

<p>
此外，当编写 if 表达式时，真假测试通常与符号 if 写在同一行上，但如果测试为真，
要执行的动作（即 then 部分）则写在第二行及随后的行上。这使得 if 表达式更易于阅读。
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(if true-or-false-test
    action-to-carry-out-if-test-is-true)
</pre>
</div>
<p>
真假测试将是一个由 Lisp 解释器求值的表达式。<br />
</p>

<p>
以下是一个你可以用通常方式求值的示例。测试是数字 5 是否大于数字 4。由于确实如此，将打印消息 “5 is greater than 4!”。
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(if (&gt; 5 4)                             ; if-part
  (message "5 is greater than 4!"))   ; then-part
</pre>
</div>
<p>
（函数 &gt; 测试它的第一个参数是否大于第二个参数，如果是，则返回 true。）<br />
</p>

<p>
当然，在实际使用中，if 表达式中的测试不会像表达式 （&gt; 5 4） 那样一直固定不变。
相反，测试中使用的变量至少有一个将绑定到一个事先未知的值。（如果值是事先已知的，我们就不需要运行测试了！）<br />
</p>

<p>
例如，这个值可能被绑定到函数定义的一个参数上。在以下函数定义中，动物的特征是传递给函数的一个值。
如果绑定到 characteristic 的值是 "fierce"，那么将打印消息 “It is a tiger!”；否则，将返回 nil。
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun type-of-animal (characteristic)
  "Print message in echo area depending on CHARACTERISTIC.
If the CHARACTERISTIC is the string \"fierce\",
then warn of a tiger."
  (if (equal characteristic "fierce")
      (message "It is a tiger!")))
</pre>
</div>
<p>
如果你在 GNU Emacs 中阅读这段内容，你可以用通常的方式对函数定义求值，将其安装到 Emacs 中，
然后你可以求值以下两个表达式来查看结果：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(type-of-animal "fierce")

(type-of-animal "striped")
</pre>
</div>
<p>
当你求值 (type-of-animal "fierce") 时，你将在回显区域看到以下消息：“It is a tiger!”；
而当你求值 (type-of-animal "striped") 时，你将在回显区域看到 nil。
</p>
</div>
</div>

<div id="outline-container-orgad65aea" class="outline-4">
<h4 id="orgad65aea"><span class="section-number-4">3.7.2.</span> type-of-animal 函数的详细解释</h4>
<div class="outline-text-4" id="text-3-7-2">
<p>
让我们详细看看 type-of-animal 函数。<br />
</p>

<p>
type-of-animal 的函数定义是通过填充两个模板的槽位来编写的，一个是整个函数定义的模板，另一个是 if 表达式的模板。<br />
</p>

<p>
对于每个非交互函数的模板如下：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun name-of-function (argument-list)
  "documentation…"
  body…)
</pre>
</div>
<p>
与这个模板匹配的函数部分如下所示：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun type-of-animal (characteristic)
  "Print message in echo area depending on CHARACTERISTIC.
If the CHARACTERISTIC is the string \"fierce\",
then warn of a tiger."
  body: the if expression)
</pre>
</div>
<p>
函数的名称是 type-of-animal；它接收一个参数的值。参数列表后面是一个多行文档字符串。
文档字符串包含在这个例子中，因为为每个函数定义编写文档字符串是一个好习惯。函数定义的主体由 if 表达式组成。<br />
</p>

<p>
if 表达式的模板如下所示：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(if true-or-false-test
  action-to-carry-out-if-the-test-returns-true)
</pre>
</div>
<p>
在 type-of-animal 函数中，if 的代码如下所示：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(if (equal characteristic "fierce")
    (message "It is a tiger!"))
</pre>
</div>
<p>
这里，真假测试是以下表达式：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(equal characteristic "fierce")
</pre>
</div>
<p>
在 Lisp 中，equal 是一个函数，用于确定它的第一个参数是否等于第二个参数。
第二个参数是字符串 "fierce"，第一个参数是符号 characteristic 的值——换句话说，就是传递给这个函数的参数。<br />
</p>

<p>
在 type-of-animal 的第一个例子中，传递给 type-of-animal 的参数是 "fierce"。
由于 "fierce" 等于 "fierce"，表达式 (equal characteristic "fierce") 返回 true。
在这种情况下，if 会求值它的第二个参数或 then 部分：(message "It is a tiger!")。<br />
</p>

<p>
另一方面，在 type-of-animal 的第二个例子中，传递给 type-of-animal 的参数是 "striped"。
由于 "striped" 不等于 "fierce"，因此 then 部分不会被求值，if 表达式返回 nil。
</p>
</div>
</div>
</div>

<div id="outline-container-orgb256e6e" class="outline-3">
<h3 id="orgb256e6e"><span class="section-number-3">3.8.</span> If–then–else 表达式</h3>
<div class="outline-text-3" id="text-3-8">
<p>
if 表达式可以有一个可选的第三个参数，称为 else 部分，用于当真假测试返回 false 时的情况。
当这种情况发生时，if 表达式的第二个参数或 then 部分不被求值，而第三个参数或 else 部分被求值。
你可以将其想象为决策“如果天气温暖且阳光明媚，那么去海滩，否则读书！”的阴天替代方案。<br />
</p>

<p>
在 Lisp 代码中没有写出单词 "else"；if 表达式的 else 部分位于 then 部分之后。
在书写的 Lisp 代码中，else 部分通常会从新的一行开始，并且缩进比 then 部分少：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(if true-or-false-test
    action-to-carry-out-if-the-test-returns-true
  action-to-carry-out-if-the-test-returns-false)
</pre>
</div>
<p>
例如，以下 if 表达式在你用通常的方式求值时会打印消息 “4 is not greater than 5!”：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(if (&gt; 4 5)                               ; if 部分
    (message "4 falsely greater than 5!") ; then 部分
  (message "4 is not greater than 5!"))   ; else 部分
</pre>
</div>
<p>
注意，不同的缩进层次使得 then 部分与 else 部分易于区分。
（GNU Emacs 有几个命令可以自动正确缩进 if 表达式。参见“GNU Emacs Helps You Type Lists”。）<br />
</p>

<p>
我们可以通过简单地在 if 表达式中添加一个额外的部分来扩展 type-of-animal 函数，使其包含 else 部分。<br />
</p>

<p>
如果你求值以下版本的 type-of-animal 函数定义以将其安装，然后求值后续的两个表达式以传递不同的参数给函数，你可以看到这样做的效果。
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun type-of-animal (characteristic)  ; Second version.
"Print message in echo area depending on CHARACTERISTIC.
If the CHARACTERISTIC is the string \"fierce\",
then warn of a tiger; else say it is not fierce."
  (if (equal characteristic "fierce")
      (message "It is a tiger!")
    (message "It is not fierce!")))
</pre>
</div>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(type-of-animal "fierce")

(type-of-animal "striped")
</pre>
</div>
<p>
当你求值 (type-of-animal "fierce") 时，你会在回显区域看到如下消息：“It is a tiger!”；
但当你求值 (type-of-animal "striped") 时，你会看到 “It is not fierce!”。<br />
</p>

<p>
（当然，如果特征是 “ferocious”，消息 “It is not fierce!” 也会被打印出来，这就会产生误导！
编写代码时，你需要考虑到某些此类参数将被 if 测试的可能性，并据此编写程序。）
</p>
</div>
</div>

<div id="outline-container-org3f52aa7" class="outline-3">
<h3 id="org3f52aa7"><span class="section-number-3">3.9.</span> Emacs Lisp 中的真与假</h3>
<div class="outline-text-3" id="text-3-9">
<p>
if 表达式中的真值测试有一个重要的方面。到目前为止，我们已经提到“真”和“假”作为谓词的值，仿佛它们是新的 Emacs Lisp 对象。
事实上，“假”只是我们老朋友 nil。除此之外，任何其他值——无论是什么——都被视为“真”。<br />
</p>

<p>
用于测试真值的表达式，如果其求值结果不是 nil，则被解释为真。
换句话说，如果测试返回的值是一个数字（如 47）、一个字符串（如 "hello"）、一个符号（除了 `nil` 之外，例如 `flowers`）、
一个列表（只要它不是空的），甚至是一个缓冲区，那么该测试结果就会被视为真。
</p>
</div>

<div id="outline-container-orge8374bd" class="outline-4">
<h4 id="orge8374bd"><span class="section-number-4">3.9.1.</span> 对 nil 的解释</h4>
<div class="outline-text-4" id="text-3-9-1">
<p>
在展示真值测试之前，我们需要解释一下 nil。<br />
</p>

<p>
在 Emacs Lisp 中，符号 nil 有两个含义。首先，它表示一个空列表。其次，它表示假值，并且是一个真假测试为假时返回的值。
nil 可以写成空列表 ()，也可以写成 nil。对于 Lisp 解释器来说，() 和 nil 是相同的。
然而，对人类而言，通常使用 nil 表示假，而使用 () 表示空列表。<br />
</p>

<p>
在 Emacs Lisp 中，任何不为 nil 的值——也就是说，不是空列表的值——都被视为真。
这意味着，如果一个求值的结果不是空列表，那么一个 if 表达式将测试为真。
例如，如果一个数字被放在测试的位置，它将被求值并返回它本身，因为数字在求值时会返回它自己。
在这种条件下，if 表达式将测试为真。只有当表达式求值为 nil（一个空列表）时，测试结果才为假。<br />
</p>

<p>
通过求值以下示例中的两个表达式，你可以看到这一点。<br />
</p>

<p>
在第一个示例中，数字 4 作为 `if` 表达式中的测试进行求值，并返回它本身；
因此，表达式的 then 部分被求值并返回，结果“true”显示在回显区域中。
在第二个示例中，nil 表示假；因此，表达式的 else 部分被求值并返回，结果“false”显示在回显区域中。
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(if 4
    'true
  'false)

(if nil
    'true
  'false)
</pre>
</div>
<p>
顺便提一下，如果测试中没有其他可用的值可以返回真，那么 Lisp 解释器将返回符号 t 表示真。
例如，表达式 (&gt; 5 4) 在求值时返回 t，你可以通过通常的方式求值来验证这一点：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(&gt; 5 4)
</pre>
</div>
<p>
另一方面，如果测试结果为假，该函数返回 nil。
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(&gt; 4 5)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgdb89f44" class="outline-3">
<h3 id="orgdb89f44"><span class="section-number-3">3.10.</span> save-excursion</h3>
<div class="outline-text-3" id="text-3-10">
<p>
save-excursion 是我们将在本章讨论的最后一个特殊形式。<br />
</p>

<p>
在用于编辑的 Emacs Lisp 程序中，save-excursion 函数非常常见。
它会保存光标的位置，执行函数体，然后如果光标的位置发生了变化，它将光标恢复到之前的位置。
其主要目的是防止用户因光标的意外移动而感到惊讶和困扰。
</p>
</div>

<div id="outline-container-orgaf44e41" class="outline-4">
<h4 id="orgaf44e41"><span class="section-number-4">3.10.1.</span> 光标位置（Point）和标记（Mark）</h4>
<div class="outline-text-4" id="text-3-10-1">
<p>
在讨论 save-excursion 之前，首先了解一下 GNU Emacs 中的光标位置（point）和标记（mark）会更有帮助。
光标位置（point）是当前光标所在的位置。光标所在的位置就是光标位置。
更准确地说，在光标看似位于字符上方的终端中，光标位置位于该字符之前。在 Emacs Lisp 中，光标位置是一个整数。
缓冲区中的第一个字符为编号 1，第二个字符为编号 2，依此类推。函数 point 返回光标的当前位置作为一个数字。
每个缓冲区都有其自身的光标位置值。<br />
</p>

<p>
标记（mark）是缓冲区中的另一个位置，其值可以通过像 C-SPC（set-mark-command）这样的命令设置。
如果设置了标记，可以使用命令 C-x C-x（exchange-point-and-mark）使光标跳转到标记位置，并将标记设置为光标之前的位置。
此外，如果设置了另一个标记，之前标记的位置将被保存到标记环（mark ring）中。
可以通过多次输入 C-u C-SPC 将光标跳转到已保存的标记。<br />
</p>

<p>
缓冲区中光标位置和标记之间的部分称为区域（region）。
许多命令作用于区域，例如 center-region、count-words-region、kill-region 和 print-region。<br />
</p>

<p>
save-excursion 这个特殊形式保存光标的位置，并在 Lisp 解释器评估该特殊形式主体中的代码后恢复这个位置。
因此，如果光标位于一段文本的开头，而某些代码将光标移动到缓冲区的末尾，那么在函数体中的表达式被评估后，
save-excursion 会将光标恢复到其原来的位置。<br />
</p>

<p>
在 Emacs 中，函数通常会在其内部操作过程中移动光标，即使用户不希望如此。
例如，count-words-region 会移动光标。为了防止用户被这些既意外又（从用户角度来看）不必要的跳转所打扰，
save-excursion 经常被用来保持光标在用户预期的位置。使用 save-excursion 是一种良好的编程习惯。<br />
</p>

<p>
为了确保“家里”保持整洁，即使 save-excursion 内部的代码出现问题（更准确地说，使用专业术语是“异常退出”），
save-excursion 也会恢复光标的位置。这个特性非常有用。<br />
</p>

<p>
除了记录光标位置的值之外，save-excursion 还会跟踪当前缓冲区，并同样恢复它。
这意味着你可以编写更改缓冲区的代码，save-excursion 会将你切换回原来的缓冲区。
这正是 save-excursion 在 append-to-buffer 中的用法。（参见 append-to-buffer 的定义。）
</p>
</div>
</div>

<div id="outline-container-org8ed3515" class="outline-4">
<h4 id="org8ed3515"><span class="section-number-4">3.10.2.</span> save-excursion 表达式的模板</h4>
<div class="outline-text-4" id="text-3-10-2">
<p>
使用 save-excursion 的代码模板非常简单：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(save-excursion
  body…)
</pre>
</div>
<p>
函数体是由一个或多个表达式组成，这些表达式将由 Lisp 解释器按顺序进行求值。
如果函数体中有多个表达式，则最后一个表达式的值将作为 save-excursion 函数的返回值。
函数体中的其他表达式只是为了其副作用而求值；而 save-excursion 本身也是仅为了其副作用而使用（即恢复光标位置）。<br />
</p>

<p>
更详细地说，save-excursion 表达式的模板如下所示：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(save-excursion
  first-expression-in-body
  second-expression-in-body
  third-expression-in-body
   …
  last-expression-in-body)
</pre>
</div>
<p>
一个表达式当然可以是一个单独的符号，也可以是一个列表。<br />
</p>

<p>
在 Emacs Lisp 代码中，save-excursion 表达式通常出现在 let 表达式的函数体中，如下所示：
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(let varlist
  (save-excursion
  body…))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orga5d5672" class="outline-3">
<h3 id="orga5d5672"><span class="section-number-3">3.11.</span> 回顾</h3>
<div class="outline-text-3" id="text-3-11">
<p>
在前几章中，我们介绍了一个宏和相当多的函数及特殊形式。以下是它们的简要描述，另包括一些尚未提及的类似函数。
</p>

<ul class="org-ul">
<li>eval-last-sexp <br />
计算光标当前位置之前的最后一个符号表达式。除非该函数在调用时有一个参数，否则其值会显示在回显区域；
如果有参数，输出将显示在当前缓冲区中。此命令通常绑定为 C-x C-e。</li>
<li>defun <br />
定义函数。这个宏包含最多五个部分：函数名称、用于传递给函数的参数模板、文档说明、可选的交互式声明，以及函数体。</li>
</ul>

<p>
例如，在 Emacs 中，dired-unmark-all-marks 函数的定义如下所示。
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun dired-unmark-all-marks ()
"Remove all marks from all files in the Dired buffer."
(interactive)
(dired-unmark-all-files ?\r))
</pre>
</div>
<ul class="org-ul">
<li><p>
interactive <br />
声明该函数可以在交互模式下使用。这个特殊形式可以跟随一个字符串，字符串包含一个或多个部分，这些部分会依次将信息传递给函数的参数。
这些部分还可以告诉解释器提示输入信息。字符串的各部分用换行符 \n 分隔。 <br />
</p>

<p>
常见的代码字符包括：
</p>

<ul class="org-ul">
<li>b 现有缓冲区的名称。</li>

<li>f 现有文件的名称。</li>

<li>p 数字前缀参数。（注意这里的 p 是小写的。）</li>

<li>r 光标位置和标记位置，作为两个数字参数，最小的在前。这是唯一一个指定两个连续参数而不是一个的代码字母。</li>
</ul>

<p>
有关 interactive 的完整代码字符列表，请参阅《GNU Emacs Lisp 参考手册》中的 Code Characters for interactive。
</p></li>

<li><p>
let <br />
声明一个变量列表用于 let 的函数体内，并给它们一个初始值，可以是 nil 或指定值；
然后计算 let 函数体内的其余表达式，并返回最后一个表达式的值。
在 let 的函数体内，Lisp 解释器不会看到与 let 外部绑定的相同名称的变量的值。<br />
</p>

<p>
例如，
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(let ((foo (buffer-name))
 (bar (buffer-size)))
(message
  "This buffer is %s and has %d characters."
  foo bar))
</pre>
</div></li>

<li><p>
save-excursion <br />
记录在评估该特殊形式的主体之前的点（point）和当前缓冲区的值。然后，在主体评估完成后，恢复点和缓冲区的值。
</p>

<p>
例如，
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(message "We are %d characters into this buffer."
       (- (point)
          (save-excursion
            (goto-char (point-min)) (point))))
</pre>
</div></li>
<li><p>
if <br />
评估函数的第一个参数；如果它为真，则评估第二个参数；否则，如果存在第三个参数，则评估第三个参数。<br />
</p>

<p>
if 特殊形式被称为条件语句。在 Emacs Lisp 中，还有其他条件语句，但 `if` 可能是最常用的。<br />
</p>

<p>
例如，
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(if (= 22 emacs-major-version)
    (message "This is version 22 Emacs")
  (message "This is not version 22 Emacs"))
</pre>
</div></li>

<li>&lt;</li>
<li>&gt;</li>
<li>&lt;=</li>
<li>&gt;=</li>
<li>&lt; <br />
&lt; 函数测试其第一个参数是否小于第二个参数。对应的函数 &gt; 测试第一个参数是否大于第二个参数。
同样，&lt;= 测试第一个参数是否小于或等于第二个参数，而 &gt;= 则测试第一个参数是否大于或等于第二个参数。
在所有情况下，两个参数都必须是数字或标记（标记指的是缓冲区中的位置）。</li>

<li>= <br />
= 函数测试两个参数（都为数字或标记）是否相等。</li>

<li>equal 和 eq <br />
测试两个对象是否相同。equal 和 eq 使用了“相同”这个词的不同含义：equal 在两个对象具有相似的结构和内容时返回真，
例如两本相同的书的副本。而 eq 则在两个参数实际上是同一个对象时返回真。</li>

<li>string&lt;</li>
<li>string-lessp</li>
<li>string=</li>
<li><p>
string-equal <br />
string-lessp 函数测试其第一个参数是否小于第二个参数。该函数的一个简短别名（由 defalias 定义）是 string&lt;。<br />
</p>

<p>
string-lessp 的参数必须是字符串或符号，比较顺序是字典序，因此大小写是区分的。符号的打印名称被用来代替符号本身进行比较。<br />
</p>

<p>
空字符串 "" （不包含任何字符的字符串）比任何字符字符串都小。<br />
</p>

<p>
string-equal 提供了相应的相等性测试，其简短别名是 string=。没有对应于 &gt;, &gt;= 或 &lt;= 的字符串测试函数。
</p></li>

<li>message <br />
在回显区打印消息。第一个参数是一个字符串，可以包含 %s、%d 或 %c，用来打印后续参数的值。
%s 的参数必须是字符串或符号，%d 的参数必须是数字。%c 的参数必须是 ASCII 码数字，将按照具有该 ASCII 码的字符进行打印。
（还有其他各种 % 序列没有提到。）</li>

<li>setq</li>
<li>set <br />
setq 是一种特殊形式，用于将其第一个参数的值设置为第二个参数的值。
setq 会自动为第一个参数加上引号，对于后续的参数对也做相同处理。</li>

<li>buffer-name <br />
在没有参数的情况下，返回当前缓冲区的名称，作为一个字符串。</li>

<li>buffer-file-name <br />
在没有参数的情况下，返回当前缓冲区正在访问的文件的名称。</li>

<li>current-buffer <br />
返回 Emacs 当前活动的缓冲区；该缓冲区可能并不是屏幕上可见的缓冲区。</li>

<li>other-buffer <br />
返回最近选择的缓冲区（除了作为参数传递给 `other-buffer` 的缓冲区和当前缓冲区之外）。</li>

<li>switch-to-buffer <br />
选择一个缓冲区让 Emacs 变为活动状态，并在当前窗口显示该缓冲区，以便用户查看。通常绑定到 `C-x b`。</li>

<li>set-buffer <br />
将 Emacs 的注意力切换到程序将要运行的缓冲区。不改变窗口所显示的内容。</li>

<li>buffer-size <br />
返回当前缓冲区中的字符数。</li>

<li>point <br />
返回光标当前位置的值，作为从缓冲区开始算起的字符数的整数。</li>

<li>point-min <br />
返回当前缓冲区中 point 的最小允许值。通常为 1，除非使用了窄化（narrowing）。</li>

<li>point-max <br />
返回当前缓冲区中 point 的最大允许值。通常为缓冲区的末尾，除非使用了窄化（narrowing）。</li>
</ul>
</div>
</div>

<div id="outline-container-orgdda7ae7" class="outline-3">
<h3 id="orgdda7ae7"><span class="section-number-3">3.12.</span> 练习</h3>
<div class="outline-text-3" id="text-3-12">
<ol class="org-ol">
<li>编写一个非交互式函数，它将其参数（一个数字）的值加倍。然后将该函数设置为交互式函数。</li>
<li>编写一个函数，测试当前 fill-column 的值是否大于传递给该函数的参数。如果是，则打印一条相应的消息。</li>
</ol>
</div>
</div>
</div>


<div id="outline-container-org4a5237e" class="outline-2">
<h2 id="org4a5237e"><span class="section-number-2">4.</span> 一些与缓冲区相关的函数</h2>
<div class="outline-text-2" id="text-4">
<p>
在本章中，我们将详细研究 GNU Emacs 中使用的几个函数。这种学习方法称为“逐步讲解”（walk-through）。
这些函数作为 Lisp 代码的示例，但并不是假想的例子；除了第一个简化的函数定义外，这些函数展示了 GNU Emacs 中实际使用的代码。
你可以从这些定义中学到很多东西。这里描述的函数都与缓冲区相关。稍后，我们将学习其他函数。
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2024-08-18</p>
<p class="author">Author: JanSky</p>
<p class="date">Created: 2024-09-04 Wed 23:36</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>